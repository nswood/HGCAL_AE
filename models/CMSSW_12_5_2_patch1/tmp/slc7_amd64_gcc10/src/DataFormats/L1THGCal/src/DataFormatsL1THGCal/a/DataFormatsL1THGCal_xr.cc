// Do NOT change. Changes will be lost next time file is generated

#define R__DICTIONARY_FILENAME tmpdIslc7_amd64_gcc10dIsrcdIDataFormatsdIL1THGCaldIsrcdIDataFormatsL1THGCaldIadIDataFormatsL1THGCal_xr
#define R__NO_DEPRECATION

/*******************************************************************/
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define G__DICTIONARY
#include "RConfig.h"
#include "TClass.h"
#include "TDictAttributeMap.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"
#include <algorithm>
#include "TCollectionProxyInfo.h"
/*******************************************************************/

#include "TDataMember.h"

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"


// Header files passed as explicit arguments
#include "src/DataFormats/L1THGCal/src/classes.h"

// Header files passed via #pragma extra_include

// The generated code does not explicitly qualify STL entities
namespace std {} using namespace std;

namespace ROOT {
   static TClass *pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR_Dictionary();
   static void pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR_TClassManip(TClass*);
   static void *new_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR(void *p = 0);
   static void *newArray_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR(Long_t size, void *p);
   static void delete_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR(void *p);
   static void deleteArray_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR(void *p);
   static void destruct_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const unsigned int,array<float,48> >*)
   {
      pair<const unsigned int,array<float,48> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const unsigned int,array<float,48> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const unsigned int,array<float,48> >", "string", 211,
                  typeid(pair<const unsigned int,array<float,48> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const unsigned int,array<float,48> >) );
      instance.SetNew(&new_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR);
      instance.SetNewArray(&newArray_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR);
      instance.SetDelete(&delete_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR);
      instance.SetDestructor(&destruct_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR);

      ::ROOT::AddClassAlternate("pair<const unsigned int,array<float,48> >","pair<const unsigned int,std::array<float,48> >");

      ::ROOT::AddClassAlternate("pair<const unsigned int,array<float,48> >","std::pair<unsigned int const, std::array<float, 48ul> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const unsigned int,array<float,48> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const unsigned int,array<float,48> >*)0x0)->GetClass();
      pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR_Dictionary();
   static void pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR_TClassManip(TClass*);
   static void *new_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR(void *p = 0);
   static void *newArray_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR(Long_t size, void *p);
   static void delete_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR(void *p);
   static void deleteArray_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR(void *p);
   static void destruct_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const unsigned int,array<float,16> >*)
   {
      pair<const unsigned int,array<float,16> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const unsigned int,array<float,16> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const unsigned int,array<float,16> >", "string", 211,
                  typeid(pair<const unsigned int,array<float,16> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const unsigned int,array<float,16> >) );
      instance.SetNew(&new_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR);
      instance.SetNewArray(&newArray_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR);
      instance.SetDelete(&delete_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR);
      instance.SetDestructor(&destruct_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR);

      ::ROOT::AddClassAlternate("pair<const unsigned int,array<float,16> >","pair<const unsigned int,std::array<float,16> >");

      ::ROOT::AddClassAlternate("pair<const unsigned int,array<float,16> >","std::pair<unsigned int const, std::array<float, 16ul> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const unsigned int,array<float,16> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const unsigned int,array<float,16> >*)0x0)->GetClass();
      pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCFETriggerDigi_Dictionary();
   static void l1tcLcLHGCFETriggerDigi_TClassManip(TClass*);
   static void *new_l1tcLcLHGCFETriggerDigi(void *p = 0);
   static void *newArray_l1tcLcLHGCFETriggerDigi(Long_t size, void *p);
   static void delete_l1tcLcLHGCFETriggerDigi(void *p);
   static void deleteArray_l1tcLcLHGCFETriggerDigi(void *p);
   static void destruct_l1tcLcLHGCFETriggerDigi(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCFETriggerDigi*)
   {
      ::l1t::HGCFETriggerDigi *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCFETriggerDigi));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCFETriggerDigi", 10, "DataFormats/L1THGCal/interface/HGCFETriggerDigi.h", 40,
                  typeid(::l1t::HGCFETriggerDigi), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCFETriggerDigi_Dictionary, isa_proxy, 12,
                  sizeof(::l1t::HGCFETriggerDigi) );
      instance.SetNew(&new_l1tcLcLHGCFETriggerDigi);
      instance.SetNewArray(&newArray_l1tcLcLHGCFETriggerDigi);
      instance.SetDelete(&delete_l1tcLcLHGCFETriggerDigi);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCFETriggerDigi);
      instance.SetDestructor(&destruct_l1tcLcLHGCFETriggerDigi);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCFETriggerDigi*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCFETriggerDigi*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCFETriggerDigi*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCFETriggerDigi_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCFETriggerDigi*)0x0)->GetClass();
      l1tcLcLHGCFETriggerDigi_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCFETriggerDigi_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_Dictionary();
   static void edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p);
   static void deleteArray_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p);
   static void destruct_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)
   {
      ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >", ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 148,
                  typeid(::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >) );
      instance.SetNew(&new_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR);

      ::ROOT::AddClassAlternate("edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >","l1t::HGCFETriggerDigiRef");

      ::ROOT::AddClassAlternate("edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >","edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi, edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >, l1t::HGCFETriggerDigi, edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi, edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >, l1t::HGCFETriggerDigi> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)0x0)->GetClass();
      edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_Dictionary();
   static void edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)
   {
      ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >", ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 32,
                  typeid(::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR);

      ::ROOT::AddClassAlternate("edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >","l1t::HGCFETriggerDigiRefVector");

      ::ROOT::AddClassAlternate("edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >","edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi, edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >, l1t::HGCFETriggerDigi, edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi, edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >, l1t::HGCFETriggerDigi> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)0x0)->GetClass();
      edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >*)
   {
      ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<unordered_map<unsigned int,array<float,48> > >", ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<unordered_map<unsigned int,array<float,48> > >","edm::Wrapper<std::unordered_map<unsigned int,std::array<float,48>,std::hash<unsigned int>,std::equal_to<unsigned int> > >");

      ::ROOT::AddClassAlternate("edm::Wrapper<unordered_map<unsigned int,array<float,48> > >","edm::Wrapper<std::unordered_map<unsigned int, std::array<float, 48ul>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<unsigned int const, std::array<float, 48ul> > > > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >*)0x0)->GetClass();
      edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >*)
   {
      ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<unordered_map<unsigned int,array<float,16> > >", ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<unordered_map<unsigned int,array<float,16> > >","edm::Wrapper<std::unordered_map<unsigned int,std::array<float,16>,std::hash<unsigned int>,std::equal_to<unsigned int> > >");

      ::ROOT::AddClassAlternate("edm::Wrapper<unordered_map<unsigned int,array<float,16> > >","edm::Wrapper<std::unordered_map<unsigned int, std::array<float, 16ul>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<unsigned int const, std::array<float, 16ul> > > > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >*)0x0)->GetClass();
      edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR_Dictionary();
   static void edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<unordered_map<unsigned int,float> >*)
   {
      ::edm::Wrapper<unordered_map<unsigned int,float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<unordered_map<unsigned int,float> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<unordered_map<unsigned int,float> >", ::edm::Wrapper<unordered_map<unsigned int,float> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<unordered_map<unsigned int,float> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<unordered_map<unsigned int,float> >) );
      instance.SetNew(&new_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<unordered_map<unsigned int,float> >","edm::Wrapper<std::unordered_map<unsigned int,float,std::hash<unsigned int>,std::equal_to<unsigned int> > >");

      ::ROOT::AddClassAlternate("edm::Wrapper<unordered_map<unsigned int,float> >","edm::Wrapper<std::unordered_map<unsigned int, float, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<unsigned int const, float> > > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<unordered_map<unsigned int,float> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<unordered_map<unsigned int,float> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<unordered_map<unsigned int,float> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<unordered_map<unsigned int,float> >*)0x0)->GetClass();
      edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >*)
   {
      ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >", ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >*)
   {
      ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >", ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >*)
   {
      ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >", ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >*)
   {
      ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >", ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >*)
   {
      ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >", ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >*)
   {
      ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >", ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >*)
   {
      ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >", ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >*)
   {
      ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >", ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >*)
   {
      ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >", ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >*)
   {
      ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >", ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary();
   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >*)
   {
      ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >", ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >) );
      instance.SetNew(&new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >","edm::Wrapper<l1t::HGCalConcentratorDataBxCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >*)0x0)->GetClass();
      edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary();
   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >*)
   {
      ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >", ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >) );
      instance.SetNew(&new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >","edm::Wrapper<l1t::HGCalTriggerSumsBxCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >*)0x0)->GetClass();
      edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary();
   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >*)
   {
      ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >", ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >) );
      instance.SetNew(&new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >","edm::Wrapper<l1t::HGCalTriggerCellBxCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >*)0x0)->GetClass();
      edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR_Dictionary();
   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >*)
   {
      ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<BXVector<l1t::HGCalMulticluster> >", ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >) );
      instance.SetNew(&new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<BXVector<l1t::HGCalMulticluster> >","edm::Wrapper<l1t::HGCalMulticlusterBxCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >*)0x0)->GetClass();
      edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR_Dictionary();
   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<BXVector<l1t::HGCalCluster> >*)
   {
      ::edm::Wrapper<BXVector<l1t::HGCalCluster> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<BXVector<l1t::HGCalCluster> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<BXVector<l1t::HGCalCluster> >", ::edm::Wrapper<BXVector<l1t::HGCalCluster> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<BXVector<l1t::HGCalCluster> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<BXVector<l1t::HGCalCluster> >) );
      instance.SetNew(&new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<BXVector<l1t::HGCalCluster> >","edm::Wrapper<l1t::HGCalClusterBxCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<BXVector<l1t::HGCalCluster> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<BXVector<l1t::HGCalCluster> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalCluster> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalCluster> >*)0x0)->GetClass();
      edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR_Dictionary();
   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >*)
   {
      ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<BXVector<l1t::HGCalTowerMap> >", ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >) );
      instance.SetNew(&new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<BXVector<l1t::HGCalTowerMap> >","edm::Wrapper<l1t::HGCalTowerMapBxCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >*)0x0)->GetClass();
      edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR_Dictionary();
   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<BXVector<l1t::HGCalTower> >*)
   {
      ::edm::Wrapper<BXVector<l1t::HGCalTower> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<BXVector<l1t::HGCalTower> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<BXVector<l1t::HGCalTower> >", ::edm::Wrapper<BXVector<l1t::HGCalTower> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<BXVector<l1t::HGCalTower> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<BXVector<l1t::HGCalTower> >) );
      instance.SetNew(&new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<BXVector<l1t::HGCalTower> >","edm::Wrapper<l1t::HGCalTowerBxCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<BXVector<l1t::HGCalTower> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<BXVector<l1t::HGCalTower> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalTower> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<BXVector<l1t::HGCalTower> >*)0x0)->GetClass();
      edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >*)
   {
      ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >", ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >","edm::Wrapper<l1t::HGCFETriggerDigiPtrVector>");

      ::ROOT::AddClassAlternate("edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >","edm::Wrapper<std::vector<edm::Ptr<l1t::HGCFETriggerDigi>, std::allocator<edm::Ptr<l1t::HGCFETriggerDigi> > > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >*)
   {
      ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >", ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >","edm::Wrapper<l1t::HGCFETriggerDigiRefVector>");

      ::ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >","edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi, edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >, l1t::HGCFETriggerDigi, edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi, edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >, l1t::HGCFETriggerDigi> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >*)
   {
      ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >", ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >","edm::Wrapper<l1t::HGCFETriggerDigiCollection>");

      ::ROOT::AddClassAlternate("edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >","edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi, edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR_Dictionary();
   static void edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR(void *p = 0);
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR(void *p);
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR(void *p);
   static void destruct_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<l1t::HGCFETriggerDigi>*)
   {
      ::edm::Ptr<l1t::HGCFETriggerDigi> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<l1t::HGCFETriggerDigi>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<l1t::HGCFETriggerDigi>", ::edm::Ptr<l1t::HGCFETriggerDigi>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 40,
                  typeid(::edm::Ptr<l1t::HGCFETriggerDigi>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Ptr<l1t::HGCFETriggerDigi>) );
      instance.SetNew(&new_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR);
      instance.SetDelete(&delete_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR);

      ::ROOT::AddClassAlternate("edm::Ptr<l1t::HGCFETriggerDigi>","l1t::HGCFETriggerDigiPtr");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<l1t::HGCFETriggerDigi>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<l1t::HGCFETriggerDigi>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCFETriggerDigi>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCFETriggerDigi>*)0x0)->GetClass();
      edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR_Dictionary();
   static void edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR(void *p = 0);
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR(void *p);
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR(void *p);
   static void destruct_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<l1t::HGCalTriggerCell>*)
   {
      ::edm::Ptr<l1t::HGCalTriggerCell> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<l1t::HGCalTriggerCell>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<l1t::HGCalTriggerCell>", ::edm::Ptr<l1t::HGCalTriggerCell>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 40,
                  typeid(::edm::Ptr<l1t::HGCalTriggerCell>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Ptr<l1t::HGCalTriggerCell>) );
      instance.SetNew(&new_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDelete(&delete_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<l1t::HGCalTriggerCell>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<l1t::HGCalTriggerCell>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCalTriggerCell>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCalTriggerCell>*)0x0)->GetClass();
      edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEl1tcLcLHGCalClustergR_Dictionary();
   static void edmcLcLPtrlEl1tcLcLHGCalClustergR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEl1tcLcLHGCalClustergR(void *p = 0);
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCalClustergR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEl1tcLcLHGCalClustergR(void *p);
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCalClustergR(void *p);
   static void destruct_edmcLcLPtrlEl1tcLcLHGCalClustergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<l1t::HGCalCluster>*)
   {
      ::edm::Ptr<l1t::HGCalCluster> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<l1t::HGCalCluster>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<l1t::HGCalCluster>", ::edm::Ptr<l1t::HGCalCluster>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 40,
                  typeid(::edm::Ptr<l1t::HGCalCluster>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEl1tcLcLHGCalClustergR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Ptr<l1t::HGCalCluster>) );
      instance.SetNew(&new_edmcLcLPtrlEl1tcLcLHGCalClustergR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEl1tcLcLHGCalClustergR);
      instance.SetDelete(&delete_edmcLcLPtrlEl1tcLcLHGCalClustergR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEl1tcLcLHGCalClustergR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEl1tcLcLHGCalClustergR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<l1t::HGCalCluster>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<l1t::HGCalCluster>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCalCluster>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEl1tcLcLHGCalClustergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCalCluster>*)0x0)->GetClass();
      edmcLcLPtrlEl1tcLcLHGCalClustergR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEl1tcLcLHGCalClustergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEl1tcLcLHGCalTowerMapgR_Dictionary();
   static void edmcLcLPtrlEl1tcLcLHGCalTowerMapgR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR(void *p = 0);
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR(void *p);
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR(void *p);
   static void destruct_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<l1t::HGCalTowerMap>*)
   {
      ::edm::Ptr<l1t::HGCalTowerMap> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<l1t::HGCalTowerMap>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<l1t::HGCalTowerMap>", ::edm::Ptr<l1t::HGCalTowerMap>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 40,
                  typeid(::edm::Ptr<l1t::HGCalTowerMap>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEl1tcLcLHGCalTowerMapgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Ptr<l1t::HGCalTowerMap>) );
      instance.SetNew(&new_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR);
      instance.SetDelete(&delete_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<l1t::HGCalTowerMap>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<l1t::HGCalTowerMap>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCalTowerMap>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEl1tcLcLHGCalTowerMapgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCalTowerMap>*)0x0)->GetClass();
      edmcLcLPtrlEl1tcLcLHGCalTowerMapgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEl1tcLcLHGCalTowerMapgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR_Dictionary();
   static void edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR(void *p = 0);
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR(void *p);
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR(void *p);
   static void destruct_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<l1t::HGCalConcentratorData>*)
   {
      ::edm::Ptr<l1t::HGCalConcentratorData> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<l1t::HGCalConcentratorData>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<l1t::HGCalConcentratorData>", ::edm::Ptr<l1t::HGCalConcentratorData>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 40,
                  typeid(::edm::Ptr<l1t::HGCalConcentratorData>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Ptr<l1t::HGCalConcentratorData>) );
      instance.SetNew(&new_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetDelete(&delete_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<l1t::HGCalConcentratorData>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<l1t::HGCalConcentratorData>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCalConcentratorData>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCalConcentratorData>*)0x0)->GetClass();
      edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR_Dictionary();
   static void edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR(void *p = 0);
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR(void *p);
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR(void *p);
   static void destruct_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<l1t::HGCalTriggerSums>*)
   {
      ::edm::Ptr<l1t::HGCalTriggerSums> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<l1t::HGCalTriggerSums>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<l1t::HGCalTriggerSums>", ::edm::Ptr<l1t::HGCalTriggerSums>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 40,
                  typeid(::edm::Ptr<l1t::HGCalTriggerSums>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Ptr<l1t::HGCalTriggerSums>) );
      instance.SetNew(&new_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDelete(&delete_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<l1t::HGCalTriggerSums>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<l1t::HGCalTriggerSums>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCalTriggerSums>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<l1t::HGCalTriggerSums>*)0x0)->GetClass();
      edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR_Dictionary();
   static void edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR_TClassManip(TClass*);
   static void *new_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR(void *p = 0);
   static void *newArray_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR(Long_t size, void *p);
   static void delete_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR(void *p);
   static void deleteArray_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR(void *p);
   static void destruct_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::PtrVector<l1t::HGCalTowerMap>*)
   {
      ::edm::PtrVector<l1t::HGCalTowerMap> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::PtrVector<l1t::HGCalTowerMap>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::PtrVector<l1t::HGCalTowerMap>", ::edm::PtrVector<l1t::HGCalTowerMap>::Class_Version(), "DataFormats/Common/interface/PtrVector.h", 122,
                  typeid(::edm::PtrVector<l1t::HGCalTowerMap>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::PtrVector<l1t::HGCalTowerMap>) );
      instance.SetNew(&new_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetNewArray(&newArray_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetDelete(&delete_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetDestructor(&destruct_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::PtrVector<l1t::HGCalTowerMap>*)
   {
      return GenerateInitInstanceLocal((::edm::PtrVector<l1t::HGCalTowerMap>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::PtrVector<l1t::HGCalTowerMap>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::PtrVector<l1t::HGCalTowerMap>*)0x0)->GetClass();
      edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR_Dictionary();
   static void edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR(void *p = 0);
   static void *newArray_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR(Long_t size, void *p);
   static void delete_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR(void *p);
   static void deleteArray_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR(void *p);
   static void destruct_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >*)
   {
      ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >", ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >::Class_Version(), "DataFormats/Common/interface/SortedCollection.h", 75,
                  typeid(::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >) );
      instance.SetNew(&new_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetNewArray(&newArray_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDelete(&delete_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDestructor(&destruct_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR);

      ::ROOT::AddClassAlternate("edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >","l1t::HGCFETriggerDigiCollection");

      ::ROOT::AddClassAlternate("edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >","edm::SortedCollection<l1t::HGCFETriggerDigi, edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >*)
   {
      return GenerateInitInstanceLocal((::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >*)0x0)->GetClass();
      edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BXVectorlEl1tcLcLHGCalTriggerCellgR_Dictionary();
   static void BXVectorlEl1tcLcLHGCalTriggerCellgR_TClassManip(TClass*);
   static void *new_BXVectorlEl1tcLcLHGCalTriggerCellgR(void *p = 0);
   static void *newArray_BXVectorlEl1tcLcLHGCalTriggerCellgR(Long_t size, void *p);
   static void delete_BXVectorlEl1tcLcLHGCalTriggerCellgR(void *p);
   static void deleteArray_BXVectorlEl1tcLcLHGCalTriggerCellgR(void *p);
   static void destruct_BXVectorlEl1tcLcLHGCalTriggerCellgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BXVector<l1t::HGCalTriggerCell>*)
   {
      ::BXVector<l1t::HGCalTriggerCell> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BXVector<l1t::HGCalTriggerCell>));
      static ::ROOT::TGenericClassInfo 
         instance("BXVector<l1t::HGCalTriggerCell>", "DataFormats/L1Trigger/interface/BXVector.h", 15,
                  typeid(::BXVector<l1t::HGCalTriggerCell>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &BXVectorlEl1tcLcLHGCalTriggerCellgR_Dictionary, isa_proxy, 4,
                  sizeof(::BXVector<l1t::HGCalTriggerCell>) );
      instance.SetNew(&new_BXVectorlEl1tcLcLHGCalTriggerCellgR);
      instance.SetNewArray(&newArray_BXVectorlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDelete(&delete_BXVectorlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDeleteArray(&deleteArray_BXVectorlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDestructor(&destruct_BXVectorlEl1tcLcLHGCalTriggerCellgR);

      ::ROOT::AddClassAlternate("BXVector<l1t::HGCalTriggerCell>","l1t::HGCalTriggerCellBxCollection");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BXVector<l1t::HGCalTriggerCell>*)
   {
      return GenerateInitInstanceLocal((::BXVector<l1t::HGCalTriggerCell>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalTriggerCell>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BXVectorlEl1tcLcLHGCalTriggerCellgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalTriggerCell>*)0x0)->GetClass();
      BXVectorlEl1tcLcLHGCalTriggerCellgR_TClassManip(theClass);
   return theClass;
   }

   static void BXVectorlEl1tcLcLHGCalTriggerCellgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BXVectorlEl1tcLcLHGCalClustergR_Dictionary();
   static void BXVectorlEl1tcLcLHGCalClustergR_TClassManip(TClass*);
   static void *new_BXVectorlEl1tcLcLHGCalClustergR(void *p = 0);
   static void *newArray_BXVectorlEl1tcLcLHGCalClustergR(Long_t size, void *p);
   static void delete_BXVectorlEl1tcLcLHGCalClustergR(void *p);
   static void deleteArray_BXVectorlEl1tcLcLHGCalClustergR(void *p);
   static void destruct_BXVectorlEl1tcLcLHGCalClustergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BXVector<l1t::HGCalCluster>*)
   {
      ::BXVector<l1t::HGCalCluster> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BXVector<l1t::HGCalCluster>));
      static ::ROOT::TGenericClassInfo 
         instance("BXVector<l1t::HGCalCluster>", "DataFormats/L1Trigger/interface/BXVector.h", 15,
                  typeid(::BXVector<l1t::HGCalCluster>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &BXVectorlEl1tcLcLHGCalClustergR_Dictionary, isa_proxy, 4,
                  sizeof(::BXVector<l1t::HGCalCluster>) );
      instance.SetNew(&new_BXVectorlEl1tcLcLHGCalClustergR);
      instance.SetNewArray(&newArray_BXVectorlEl1tcLcLHGCalClustergR);
      instance.SetDelete(&delete_BXVectorlEl1tcLcLHGCalClustergR);
      instance.SetDeleteArray(&deleteArray_BXVectorlEl1tcLcLHGCalClustergR);
      instance.SetDestructor(&destruct_BXVectorlEl1tcLcLHGCalClustergR);

      ::ROOT::AddClassAlternate("BXVector<l1t::HGCalCluster>","l1t::HGCalClusterBxCollection");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BXVector<l1t::HGCalCluster>*)
   {
      return GenerateInitInstanceLocal((::BXVector<l1t::HGCalCluster>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalCluster>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BXVectorlEl1tcLcLHGCalClustergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalCluster>*)0x0)->GetClass();
      BXVectorlEl1tcLcLHGCalClustergR_TClassManip(theClass);
   return theClass;
   }

   static void BXVectorlEl1tcLcLHGCalClustergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BXVectorlEl1tcLcLHGCalMulticlustergR_Dictionary();
   static void BXVectorlEl1tcLcLHGCalMulticlustergR_TClassManip(TClass*);
   static void *new_BXVectorlEl1tcLcLHGCalMulticlustergR(void *p = 0);
   static void *newArray_BXVectorlEl1tcLcLHGCalMulticlustergR(Long_t size, void *p);
   static void delete_BXVectorlEl1tcLcLHGCalMulticlustergR(void *p);
   static void deleteArray_BXVectorlEl1tcLcLHGCalMulticlustergR(void *p);
   static void destruct_BXVectorlEl1tcLcLHGCalMulticlustergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BXVector<l1t::HGCalMulticluster>*)
   {
      ::BXVector<l1t::HGCalMulticluster> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BXVector<l1t::HGCalMulticluster>));
      static ::ROOT::TGenericClassInfo 
         instance("BXVector<l1t::HGCalMulticluster>", "DataFormats/L1Trigger/interface/BXVector.h", 15,
                  typeid(::BXVector<l1t::HGCalMulticluster>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &BXVectorlEl1tcLcLHGCalMulticlustergR_Dictionary, isa_proxy, 4,
                  sizeof(::BXVector<l1t::HGCalMulticluster>) );
      instance.SetNew(&new_BXVectorlEl1tcLcLHGCalMulticlustergR);
      instance.SetNewArray(&newArray_BXVectorlEl1tcLcLHGCalMulticlustergR);
      instance.SetDelete(&delete_BXVectorlEl1tcLcLHGCalMulticlustergR);
      instance.SetDeleteArray(&deleteArray_BXVectorlEl1tcLcLHGCalMulticlustergR);
      instance.SetDestructor(&destruct_BXVectorlEl1tcLcLHGCalMulticlustergR);

      ::ROOT::AddClassAlternate("BXVector<l1t::HGCalMulticluster>","l1t::HGCalMulticlusterBxCollection");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BXVector<l1t::HGCalMulticluster>*)
   {
      return GenerateInitInstanceLocal((::BXVector<l1t::HGCalMulticluster>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalMulticluster>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BXVectorlEl1tcLcLHGCalMulticlustergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalMulticluster>*)0x0)->GetClass();
      BXVectorlEl1tcLcLHGCalMulticlustergR_TClassManip(theClass);
   return theClass;
   }

   static void BXVectorlEl1tcLcLHGCalMulticlustergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BXVectorlEl1tcLcLHGCalTowergR_Dictionary();
   static void BXVectorlEl1tcLcLHGCalTowergR_TClassManip(TClass*);
   static void *new_BXVectorlEl1tcLcLHGCalTowergR(void *p = 0);
   static void *newArray_BXVectorlEl1tcLcLHGCalTowergR(Long_t size, void *p);
   static void delete_BXVectorlEl1tcLcLHGCalTowergR(void *p);
   static void deleteArray_BXVectorlEl1tcLcLHGCalTowergR(void *p);
   static void destruct_BXVectorlEl1tcLcLHGCalTowergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BXVector<l1t::HGCalTower>*)
   {
      ::BXVector<l1t::HGCalTower> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BXVector<l1t::HGCalTower>));
      static ::ROOT::TGenericClassInfo 
         instance("BXVector<l1t::HGCalTower>", "DataFormats/L1Trigger/interface/BXVector.h", 15,
                  typeid(::BXVector<l1t::HGCalTower>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &BXVectorlEl1tcLcLHGCalTowergR_Dictionary, isa_proxy, 4,
                  sizeof(::BXVector<l1t::HGCalTower>) );
      instance.SetNew(&new_BXVectorlEl1tcLcLHGCalTowergR);
      instance.SetNewArray(&newArray_BXVectorlEl1tcLcLHGCalTowergR);
      instance.SetDelete(&delete_BXVectorlEl1tcLcLHGCalTowergR);
      instance.SetDeleteArray(&deleteArray_BXVectorlEl1tcLcLHGCalTowergR);
      instance.SetDestructor(&destruct_BXVectorlEl1tcLcLHGCalTowergR);

      ::ROOT::AddClassAlternate("BXVector<l1t::HGCalTower>","l1t::HGCalTowerBxCollection");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BXVector<l1t::HGCalTower>*)
   {
      return GenerateInitInstanceLocal((::BXVector<l1t::HGCalTower>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalTower>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BXVectorlEl1tcLcLHGCalTowergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalTower>*)0x0)->GetClass();
      BXVectorlEl1tcLcLHGCalTowergR_TClassManip(theClass);
   return theClass;
   }

   static void BXVectorlEl1tcLcLHGCalTowergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BXVectorlEl1tcLcLHGCalTowerMapgR_Dictionary();
   static void BXVectorlEl1tcLcLHGCalTowerMapgR_TClassManip(TClass*);
   static void *new_BXVectorlEl1tcLcLHGCalTowerMapgR(void *p = 0);
   static void *newArray_BXVectorlEl1tcLcLHGCalTowerMapgR(Long_t size, void *p);
   static void delete_BXVectorlEl1tcLcLHGCalTowerMapgR(void *p);
   static void deleteArray_BXVectorlEl1tcLcLHGCalTowerMapgR(void *p);
   static void destruct_BXVectorlEl1tcLcLHGCalTowerMapgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BXVector<l1t::HGCalTowerMap>*)
   {
      ::BXVector<l1t::HGCalTowerMap> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BXVector<l1t::HGCalTowerMap>));
      static ::ROOT::TGenericClassInfo 
         instance("BXVector<l1t::HGCalTowerMap>", "DataFormats/L1Trigger/interface/BXVector.h", 15,
                  typeid(::BXVector<l1t::HGCalTowerMap>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &BXVectorlEl1tcLcLHGCalTowerMapgR_Dictionary, isa_proxy, 4,
                  sizeof(::BXVector<l1t::HGCalTowerMap>) );
      instance.SetNew(&new_BXVectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetNewArray(&newArray_BXVectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetDelete(&delete_BXVectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetDeleteArray(&deleteArray_BXVectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetDestructor(&destruct_BXVectorlEl1tcLcLHGCalTowerMapgR);

      ::ROOT::AddClassAlternate("BXVector<l1t::HGCalTowerMap>","l1t::HGCalTowerMapBxCollection");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BXVector<l1t::HGCalTowerMap>*)
   {
      return GenerateInitInstanceLocal((::BXVector<l1t::HGCalTowerMap>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalTowerMap>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BXVectorlEl1tcLcLHGCalTowerMapgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalTowerMap>*)0x0)->GetClass();
      BXVectorlEl1tcLcLHGCalTowerMapgR_TClassManip(theClass);
   return theClass;
   }

   static void BXVectorlEl1tcLcLHGCalTowerMapgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BXVectorlEl1tcLcLHGCalTriggerSumsgR_Dictionary();
   static void BXVectorlEl1tcLcLHGCalTriggerSumsgR_TClassManip(TClass*);
   static void *new_BXVectorlEl1tcLcLHGCalTriggerSumsgR(void *p = 0);
   static void *newArray_BXVectorlEl1tcLcLHGCalTriggerSumsgR(Long_t size, void *p);
   static void delete_BXVectorlEl1tcLcLHGCalTriggerSumsgR(void *p);
   static void deleteArray_BXVectorlEl1tcLcLHGCalTriggerSumsgR(void *p);
   static void destruct_BXVectorlEl1tcLcLHGCalTriggerSumsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BXVector<l1t::HGCalTriggerSums>*)
   {
      ::BXVector<l1t::HGCalTriggerSums> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BXVector<l1t::HGCalTriggerSums>));
      static ::ROOT::TGenericClassInfo 
         instance("BXVector<l1t::HGCalTriggerSums>", "DataFormats/L1Trigger/interface/BXVector.h", 15,
                  typeid(::BXVector<l1t::HGCalTriggerSums>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &BXVectorlEl1tcLcLHGCalTriggerSumsgR_Dictionary, isa_proxy, 4,
                  sizeof(::BXVector<l1t::HGCalTriggerSums>) );
      instance.SetNew(&new_BXVectorlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetNewArray(&newArray_BXVectorlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDelete(&delete_BXVectorlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDeleteArray(&deleteArray_BXVectorlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDestructor(&destruct_BXVectorlEl1tcLcLHGCalTriggerSumsgR);

      ::ROOT::AddClassAlternate("BXVector<l1t::HGCalTriggerSums>","l1t::HGCalTriggerSumsBxCollection");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BXVector<l1t::HGCalTriggerSums>*)
   {
      return GenerateInitInstanceLocal((::BXVector<l1t::HGCalTriggerSums>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalTriggerSums>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BXVectorlEl1tcLcLHGCalTriggerSumsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalTriggerSums>*)0x0)->GetClass();
      BXVectorlEl1tcLcLHGCalTriggerSumsgR_TClassManip(theClass);
   return theClass;
   }

   static void BXVectorlEl1tcLcLHGCalTriggerSumsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BXVectorlEl1tcLcLHGCalConcentratorDatagR_Dictionary();
   static void BXVectorlEl1tcLcLHGCalConcentratorDatagR_TClassManip(TClass*);
   static void *new_BXVectorlEl1tcLcLHGCalConcentratorDatagR(void *p = 0);
   static void *newArray_BXVectorlEl1tcLcLHGCalConcentratorDatagR(Long_t size, void *p);
   static void delete_BXVectorlEl1tcLcLHGCalConcentratorDatagR(void *p);
   static void deleteArray_BXVectorlEl1tcLcLHGCalConcentratorDatagR(void *p);
   static void destruct_BXVectorlEl1tcLcLHGCalConcentratorDatagR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BXVector<l1t::HGCalConcentratorData>*)
   {
      ::BXVector<l1t::HGCalConcentratorData> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BXVector<l1t::HGCalConcentratorData>));
      static ::ROOT::TGenericClassInfo 
         instance("BXVector<l1t::HGCalConcentratorData>", "DataFormats/L1Trigger/interface/BXVector.h", 15,
                  typeid(::BXVector<l1t::HGCalConcentratorData>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &BXVectorlEl1tcLcLHGCalConcentratorDatagR_Dictionary, isa_proxy, 4,
                  sizeof(::BXVector<l1t::HGCalConcentratorData>) );
      instance.SetNew(&new_BXVectorlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetNewArray(&newArray_BXVectorlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetDelete(&delete_BXVectorlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetDeleteArray(&deleteArray_BXVectorlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetDestructor(&destruct_BXVectorlEl1tcLcLHGCalConcentratorDatagR);

      ::ROOT::AddClassAlternate("BXVector<l1t::HGCalConcentratorData>","l1t::HGCalConcentratorDataBxCollection");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BXVector<l1t::HGCalConcentratorData>*)
   {
      return GenerateInitInstanceLocal((::BXVector<l1t::HGCalConcentratorData>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalConcentratorData>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BXVectorlEl1tcLcLHGCalConcentratorDatagR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BXVector<l1t::HGCalConcentratorData>*)0x0)->GetClass();
      BXVectorlEl1tcLcLHGCalConcentratorDatagR_TClassManip(theClass);
   return theClass;
   }

   static void BXVectorlEl1tcLcLHGCalConcentratorDatagR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalTriggerCell_Dictionary();
   static void l1tcLcLHGCalTriggerCell_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalTriggerCell(void *p = 0);
   static void *newArray_l1tcLcLHGCalTriggerCell(Long_t size, void *p);
   static void delete_l1tcLcLHGCalTriggerCell(void *p);
   static void deleteArray_l1tcLcLHGCalTriggerCell(void *p);
   static void destruct_l1tcLcLHGCalTriggerCell(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalTriggerCell*)
   {
      ::l1t::HGCalTriggerCell *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalTriggerCell));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalTriggerCell", 12, "DataFormats/L1THGCal/interface/HGCalTriggerCell.h", 14,
                  typeid(::l1t::HGCalTriggerCell), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalTriggerCell_Dictionary, isa_proxy, 12,
                  sizeof(::l1t::HGCalTriggerCell) );
      instance.SetNew(&new_l1tcLcLHGCalTriggerCell);
      instance.SetNewArray(&newArray_l1tcLcLHGCalTriggerCell);
      instance.SetDelete(&delete_l1tcLcLHGCalTriggerCell);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalTriggerCell);
      instance.SetDestructor(&destruct_l1tcLcLHGCalTriggerCell);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalTriggerCell*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalTriggerCell*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalTriggerCell*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalTriggerCell_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalTriggerCell*)0x0)->GetClass();
      l1tcLcLHGCalTriggerCell_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalTriggerCell_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR_Dictionary();
   static void l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR(void *p = 0);
   static void *newArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR(Long_t size, void *p);
   static void delete_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR(void *p);
   static void deleteArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR(void *p);
   static void destruct_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalClusterT<l1t::HGCalTriggerCell>*)
   {
      ::l1t::HGCalClusterT<l1t::HGCalTriggerCell> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalClusterT<l1t::HGCalTriggerCell>));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalClusterT<l1t::HGCalTriggerCell>", "DataFormats/L1THGCal/interface/HGCalClusterT.h", 20,
                  typeid(::l1t::HGCalClusterT<l1t::HGCalTriggerCell>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR_Dictionary, isa_proxy, 4,
                  sizeof(::l1t::HGCalClusterT<l1t::HGCalTriggerCell>) );
      instance.SetNew(&new_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR);
      instance.SetNewArray(&newArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDelete(&delete_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDestructor(&destruct_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalClusterT<l1t::HGCalTriggerCell>*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalClusterT<l1t::HGCalTriggerCell>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalClusterT<l1t::HGCalTriggerCell>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalClusterT<l1t::HGCalTriggerCell>*)0x0)->GetClass();
      l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR_Dictionary();
   static void l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR(void *p = 0);
   static void *newArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR(Long_t size, void *p);
   static void delete_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR(void *p);
   static void deleteArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR(void *p);
   static void destruct_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalClusterT<l1t::HGCalCluster>*)
   {
      ::l1t::HGCalClusterT<l1t::HGCalCluster> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalClusterT<l1t::HGCalCluster>));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalClusterT<l1t::HGCalCluster>", "DataFormats/L1THGCal/interface/HGCalClusterT.h", 20,
                  typeid(::l1t::HGCalClusterT<l1t::HGCalCluster>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR_Dictionary, isa_proxy, 4,
                  sizeof(::l1t::HGCalClusterT<l1t::HGCalCluster>) );
      instance.SetNew(&new_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR);
      instance.SetNewArray(&newArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR);
      instance.SetDelete(&delete_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR);
      instance.SetDestructor(&destruct_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalClusterT<l1t::HGCalCluster>*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalClusterT<l1t::HGCalCluster>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalClusterT<l1t::HGCalCluster>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalClusterT<l1t::HGCalCluster>*)0x0)->GetClass();
      l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR_Dictionary();
   static void l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR(void *p = 0);
   static void *newArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR(Long_t size, void *p);
   static void delete_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR(void *p);
   static void deleteArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR(void *p);
   static void destruct_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalClusterT<l1t::HGCalTriggerSums>*)
   {
      ::l1t::HGCalClusterT<l1t::HGCalTriggerSums> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalClusterT<l1t::HGCalTriggerSums>));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalClusterT<l1t::HGCalTriggerSums>", "DataFormats/L1THGCal/interface/HGCalClusterT.h", 20,
                  typeid(::l1t::HGCalClusterT<l1t::HGCalTriggerSums>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR_Dictionary, isa_proxy, 4,
                  sizeof(::l1t::HGCalClusterT<l1t::HGCalTriggerSums>) );
      instance.SetNew(&new_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetNewArray(&newArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDelete(&delete_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDestructor(&destruct_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalClusterT<l1t::HGCalTriggerSums>*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalClusterT<l1t::HGCalTriggerSums>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalClusterT<l1t::HGCalTriggerSums>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalClusterT<l1t::HGCalTriggerSums>*)0x0)->GetClass();
      l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalCluster_Dictionary();
   static void l1tcLcLHGCalCluster_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalCluster(void *p = 0);
   static void *newArray_l1tcLcLHGCalCluster(Long_t size, void *p);
   static void delete_l1tcLcLHGCalCluster(void *p);
   static void deleteArray_l1tcLcLHGCalCluster(void *p);
   static void destruct_l1tcLcLHGCalCluster(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalCluster*)
   {
      ::l1t::HGCalCluster *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalCluster));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalCluster", 19, "DataFormats/L1THGCal/interface/HGCalCluster.h", 11,
                  typeid(::l1t::HGCalCluster), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalCluster_Dictionary, isa_proxy, 12,
                  sizeof(::l1t::HGCalCluster) );
      instance.SetNew(&new_l1tcLcLHGCalCluster);
      instance.SetNewArray(&newArray_l1tcLcLHGCalCluster);
      instance.SetDelete(&delete_l1tcLcLHGCalCluster);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalCluster);
      instance.SetDestructor(&destruct_l1tcLcLHGCalCluster);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalCluster*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalCluster*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalCluster*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalCluster_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalCluster*)0x0)->GetClass();
      l1tcLcLHGCalCluster_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalCluster_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalMulticluster_Dictionary();
   static void l1tcLcLHGCalMulticluster_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalMulticluster(void *p = 0);
   static void *newArray_l1tcLcLHGCalMulticluster(Long_t size, void *p);
   static void delete_l1tcLcLHGCalMulticluster(void *p);
   static void deleteArray_l1tcLcLHGCalMulticluster(void *p);
   static void destruct_l1tcLcLHGCalMulticluster(void *p);

   // Schema evolution read functions
   static void read_l1tcLcLHGCalMulticluster_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("l1t::HGCalMulticluster");
      static Long_t offset_hOverE_ = cls->GetDataMemberOffset("hOverE_");
      float& hOverE_ = *(float*)(target+offset_hOverE_);
      l1t::HGCalMulticluster* newObj = (l1t::HGCalMulticluster*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      hOverE_ = -99; 
   }
   static void read_l1tcLcLHGCalMulticluster_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("l1t::HGCalMulticluster");
      static Long_t offset_hOverEValid_ = cls->GetDataMemberOffset("hOverEValid_");
      bool& hOverEValid_ = *(bool*)(target+offset_hOverEValid_);
      l1t::HGCalMulticluster* newObj = (l1t::HGCalMulticluster*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      hOverEValid_ = false; 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalMulticluster*)
   {
      ::l1t::HGCalMulticluster *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalMulticluster));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalMulticluster", 20, "DataFormats/L1THGCal/interface/HGCalMulticluster.h", 13,
                  typeid(::l1t::HGCalMulticluster), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalMulticluster_Dictionary, isa_proxy, 12,
                  sizeof(::l1t::HGCalMulticluster) );
      instance.SetNew(&new_l1tcLcLHGCalMulticluster);
      instance.SetNewArray(&newArray_l1tcLcLHGCalMulticluster);
      instance.SetDelete(&delete_l1tcLcLHGCalMulticluster);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalMulticluster);
      instance.SetDestructor(&destruct_l1tcLcLHGCalMulticluster);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(2);
      rule = &readrules[0];
      rule->fSourceClass = "l1t::HGCalMulticluster";
      rule->fTarget      = "hOverE_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_l1tcLcLHGCalMulticluster_0);
      rule->fCode        = " hOverE_ = -99; ";
      rule->fVersion     = "[-15]";
      rule->fEmbed       = false;
      rule = &readrules[1];
      rule->fSourceClass = "l1t::HGCalMulticluster";
      rule->fTarget      = "hOverEValid_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_l1tcLcLHGCalMulticluster_1);
      rule->fCode        = " hOverEValid_ = false; ";
      rule->fVersion     = "[-15]";
      rule->fEmbed       = false;
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalMulticluster*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalMulticluster*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalMulticluster*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalMulticluster_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalMulticluster*)0x0)->GetClass();
      l1tcLcLHGCalMulticluster_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalMulticluster_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalTowerID_Dictionary();
   static void l1tcLcLHGCalTowerID_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalTowerID(void *p = 0);
   static void *newArray_l1tcLcLHGCalTowerID(Long_t size, void *p);
   static void delete_l1tcLcLHGCalTowerID(void *p);
   static void deleteArray_l1tcLcLHGCalTowerID(void *p);
   static void destruct_l1tcLcLHGCalTowerID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalTowerID*)
   {
      ::l1t::HGCalTowerID *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalTowerID));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalTowerID", "DataFormats/L1THGCal/interface/HGCalTowerID.h", 10,
                  typeid(::l1t::HGCalTowerID), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalTowerID_Dictionary, isa_proxy, 4,
                  sizeof(::l1t::HGCalTowerID) );
      instance.SetNew(&new_l1tcLcLHGCalTowerID);
      instance.SetNewArray(&newArray_l1tcLcLHGCalTowerID);
      instance.SetDelete(&delete_l1tcLcLHGCalTowerID);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalTowerID);
      instance.SetDestructor(&destruct_l1tcLcLHGCalTowerID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalTowerID*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalTowerID*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalTowerID*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalTowerID_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalTowerID*)0x0)->GetClass();
      l1tcLcLHGCalTowerID_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalTowerID_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalTower_Dictionary();
   static void l1tcLcLHGCalTower_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalTower(void *p = 0);
   static void *newArray_l1tcLcLHGCalTower(Long_t size, void *p);
   static void delete_l1tcLcLHGCalTower(void *p);
   static void deleteArray_l1tcLcLHGCalTower(void *p);
   static void destruct_l1tcLcLHGCalTower(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalTower*)
   {
      ::l1t::HGCalTower *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalTower));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalTower", "DataFormats/L1THGCal/interface/HGCalTower.h", 13,
                  typeid(::l1t::HGCalTower), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalTower_Dictionary, isa_proxy, 4,
                  sizeof(::l1t::HGCalTower) );
      instance.SetNew(&new_l1tcLcLHGCalTower);
      instance.SetNewArray(&newArray_l1tcLcLHGCalTower);
      instance.SetDelete(&delete_l1tcLcLHGCalTower);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalTower);
      instance.SetDestructor(&destruct_l1tcLcLHGCalTower);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalTower*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalTower*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalTower*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalTower_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalTower*)0x0)->GetClass();
      l1tcLcLHGCalTower_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalTower_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalTowerMap_Dictionary();
   static void l1tcLcLHGCalTowerMap_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalTowerMap(void *p = 0);
   static void *newArray_l1tcLcLHGCalTowerMap(Long_t size, void *p);
   static void delete_l1tcLcLHGCalTowerMap(void *p);
   static void deleteArray_l1tcLcLHGCalTowerMap(void *p);
   static void destruct_l1tcLcLHGCalTowerMap(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalTowerMap*)
   {
      ::l1t::HGCalTowerMap *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalTowerMap));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalTowerMap", "DataFormats/L1THGCal/interface/HGCalTowerMap.h", 15,
                  typeid(::l1t::HGCalTowerMap), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalTowerMap_Dictionary, isa_proxy, 4,
                  sizeof(::l1t::HGCalTowerMap) );
      instance.SetNew(&new_l1tcLcLHGCalTowerMap);
      instance.SetNewArray(&newArray_l1tcLcLHGCalTowerMap);
      instance.SetDelete(&delete_l1tcLcLHGCalTowerMap);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalTowerMap);
      instance.SetDestructor(&destruct_l1tcLcLHGCalTowerMap);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalTowerMap*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalTowerMap*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalTowerMap*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalTowerMap_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalTowerMap*)0x0)->GetClass();
      l1tcLcLHGCalTowerMap_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalTowerMap_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalTriggerSums_Dictionary();
   static void l1tcLcLHGCalTriggerSums_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalTriggerSums(void *p = 0);
   static void *newArray_l1tcLcLHGCalTriggerSums(Long_t size, void *p);
   static void delete_l1tcLcLHGCalTriggerSums(void *p);
   static void deleteArray_l1tcLcLHGCalTriggerSums(void *p);
   static void destruct_l1tcLcLHGCalTriggerSums(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalTriggerSums*)
   {
      ::l1t::HGCalTriggerSums *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalTriggerSums));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalTriggerSums", 12, "DataFormats/L1THGCal/interface/HGCalTriggerSums.h", 14,
                  typeid(::l1t::HGCalTriggerSums), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalTriggerSums_Dictionary, isa_proxy, 12,
                  sizeof(::l1t::HGCalTriggerSums) );
      instance.SetNew(&new_l1tcLcLHGCalTriggerSums);
      instance.SetNewArray(&newArray_l1tcLcLHGCalTriggerSums);
      instance.SetDelete(&delete_l1tcLcLHGCalTriggerSums);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalTriggerSums);
      instance.SetDestructor(&destruct_l1tcLcLHGCalTriggerSums);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalTriggerSums*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalTriggerSums*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalTriggerSums*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalTriggerSums_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalTriggerSums*)0x0)->GetClass();
      l1tcLcLHGCalTriggerSums_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalTriggerSums_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLHGCalConcentratorData_Dictionary();
   static void l1tcLcLHGCalConcentratorData_TClassManip(TClass*);
   static void *new_l1tcLcLHGCalConcentratorData(void *p = 0);
   static void *newArray_l1tcLcLHGCalConcentratorData(Long_t size, void *p);
   static void delete_l1tcLcLHGCalConcentratorData(void *p);
   static void deleteArray_l1tcLcLHGCalConcentratorData(void *p);
   static void destruct_l1tcLcLHGCalConcentratorData(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::HGCalConcentratorData*)
   {
      ::l1t::HGCalConcentratorData *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::HGCalConcentratorData));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::HGCalConcentratorData", "DataFormats/L1THGCal/interface/HGCalConcentratorData.h", 12,
                  typeid(::l1t::HGCalConcentratorData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLHGCalConcentratorData_Dictionary, isa_proxy, 4,
                  sizeof(::l1t::HGCalConcentratorData) );
      instance.SetNew(&new_l1tcLcLHGCalConcentratorData);
      instance.SetNewArray(&newArray_l1tcLcLHGCalConcentratorData);
      instance.SetDelete(&delete_l1tcLcLHGCalConcentratorData);
      instance.SetDeleteArray(&deleteArray_l1tcLcLHGCalConcentratorData);
      instance.SetDestructor(&destruct_l1tcLcLHGCalConcentratorData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::HGCalConcentratorData*)
   {
      return GenerateInitInstanceLocal((::l1t::HGCalConcentratorData*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::HGCalConcentratorData*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLHGCalConcentratorData_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::HGCalConcentratorData*)0x0)->GetClass();
      l1tcLcLHGCalConcentratorData_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLHGCalConcentratorData_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *l1tcLcLClusterShapes_Dictionary();
   static void l1tcLcLClusterShapes_TClassManip(TClass*);
   static void *new_l1tcLcLClusterShapes(void *p = 0);
   static void *newArray_l1tcLcLClusterShapes(Long_t size, void *p);
   static void delete_l1tcLcLClusterShapes(void *p);
   static void deleteArray_l1tcLcLClusterShapes(void *p);
   static void destruct_l1tcLcLClusterShapes(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::l1t::ClusterShapes*)
   {
      ::l1t::ClusterShapes *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::l1t::ClusterShapes));
      static ::ROOT::TGenericClassInfo 
         instance("l1t::ClusterShapes", "DataFormats/L1THGCal/interface/ClusterShapes.h", 9,
                  typeid(::l1t::ClusterShapes), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &l1tcLcLClusterShapes_Dictionary, isa_proxy, 4,
                  sizeof(::l1t::ClusterShapes) );
      instance.SetNew(&new_l1tcLcLClusterShapes);
      instance.SetNewArray(&newArray_l1tcLcLClusterShapes);
      instance.SetDelete(&delete_l1tcLcLClusterShapes);
      instance.SetDeleteArray(&deleteArray_l1tcLcLClusterShapes);
      instance.SetDestructor(&destruct_l1tcLcLClusterShapes);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::l1t::ClusterShapes*)
   {
      return GenerateInitInstanceLocal((::l1t::ClusterShapes*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::l1t::ClusterShapes*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *l1tcLcLClusterShapes_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::l1t::ClusterShapes*)0x0)->GetClass();
      l1tcLcLClusterShapes_TClassManip(theClass);
   return theClass;
   }

   static void l1tcLcLClusterShapes_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const unsigned int,array<float,48> > : new pair<const unsigned int,array<float,48> >;
   }
   static void *newArray_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const unsigned int,array<float,48> >[nElements] : new pair<const unsigned int,array<float,48> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR(void *p) {
      delete ((pair<const unsigned int,array<float,48> >*)p);
   }
   static void deleteArray_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR(void *p) {
      delete [] ((pair<const unsigned int,array<float,48> >*)p);
   }
   static void destruct_pairlEconstsPunsignedsPintcOarraylEfloatcO48gRsPgR(void *p) {
      typedef pair<const unsigned int,array<float,48> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const unsigned int,array<float,48> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const unsigned int,array<float,16> > : new pair<const unsigned int,array<float,16> >;
   }
   static void *newArray_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const unsigned int,array<float,16> >[nElements] : new pair<const unsigned int,array<float,16> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR(void *p) {
      delete ((pair<const unsigned int,array<float,16> >*)p);
   }
   static void deleteArray_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR(void *p) {
      delete [] ((pair<const unsigned int,array<float,16> >*)p);
   }
   static void destruct_pairlEconstsPunsignedsPintcOarraylEfloatcO16gRsPgR(void *p) {
      typedef pair<const unsigned int,array<float,16> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const unsigned int,array<float,16> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCFETriggerDigi(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCFETriggerDigi : new ::l1t::HGCFETriggerDigi;
   }
   static void *newArray_l1tcLcLHGCFETriggerDigi(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCFETriggerDigi[nElements] : new ::l1t::HGCFETriggerDigi[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCFETriggerDigi(void *p) {
      delete ((::l1t::HGCFETriggerDigi*)p);
   }
   static void deleteArray_l1tcLcLHGCFETriggerDigi(void *p) {
      delete [] ((::l1t::HGCFETriggerDigi*)p);
   }
   static void destruct_l1tcLcLHGCFETriggerDigi(void *p) {
      typedef ::l1t::HGCFETriggerDigi current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCFETriggerDigi

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > : new ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >;
   }
   static void *newArray_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >[nElements] : new ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      delete ((::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)p);
   }
   static void deleteArray_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      delete [] ((::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)p);
   }
   static void destruct_edmcLcLReflEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      typedef ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > : new ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >;
   }
   static void *newArray_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >[nElements] : new ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      delete ((::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      delete [] ((::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      typedef ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > > : new ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >;
   }
   static void *newArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >[nElements] : new ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<unordered_map<unsigned int,array<float,48> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > > : new ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >;
   }
   static void *newArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >[nElements] : new ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEunordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<unordered_map<unsigned int,array<float,16> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<unordered_map<unsigned int,float> > : new ::edm::Wrapper<unordered_map<unsigned int,float> >;
   }
   static void *newArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<unordered_map<unsigned int,float> >[nElements] : new ::edm::Wrapper<unordered_map<unsigned int,float> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR(void *p) {
      delete ((::edm::Wrapper<unordered_map<unsigned int,float> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<unordered_map<unsigned int,float> >*)p);
   }
   static void destruct_edmcLcLWrapperlEunordered_maplEunsignedsPintcOfloatgRsPgR(void *p) {
      typedef ::edm::Wrapper<unordered_map<unsigned int,float> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<unordered_map<unsigned int,float> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> > : new ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >[nElements] : new ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> > : new ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >[nElements] : new ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> > : new ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >[nElements] : new ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalClustergRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> > : new ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >[nElements] : new ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> > : new ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >[nElements] : new ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> > : new ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >[nElements] : new ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> > : new ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >[nElements] : new ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> > : new ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >[nElements] : new ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> > : new ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >[nElements] : new ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> > : new ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >[nElements] : new ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> > : new ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >;
   }
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >[nElements] : new ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      delete ((::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      delete [] ((::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >*)p);
   }
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      typedef ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> > : new ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >;
   }
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >[nElements] : new ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      delete ((::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >*)p);
   }
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      typedef ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> > : new ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >;
   }
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >[nElements] : new ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      delete ((::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >*)p);
   }
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      typedef ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> > : new ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >;
   }
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >[nElements] : new ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR(void *p) {
      delete ((::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR(void *p) {
      delete [] ((::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >*)p);
   }
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalMulticlustergRsPgR(void *p) {
      typedef ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<BXVector<l1t::HGCalMulticluster> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalCluster> > : new ::edm::Wrapper<BXVector<l1t::HGCalCluster> >;
   }
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalCluster> >[nElements] : new ::edm::Wrapper<BXVector<l1t::HGCalCluster> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR(void *p) {
      delete ((::edm::Wrapper<BXVector<l1t::HGCalCluster> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR(void *p) {
      delete [] ((::edm::Wrapper<BXVector<l1t::HGCalCluster> >*)p);
   }
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalClustergRsPgR(void *p) {
      typedef ::edm::Wrapper<BXVector<l1t::HGCalCluster> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<BXVector<l1t::HGCalCluster> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> > : new ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >;
   }
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >[nElements] : new ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      delete ((::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >*)p);
   }
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowerMapgRsPgR(void *p) {
      typedef ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<BXVector<l1t::HGCalTowerMap> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalTower> > : new ::edm::Wrapper<BXVector<l1t::HGCalTower> >;
   }
   static void *newArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<BXVector<l1t::HGCalTower> >[nElements] : new ::edm::Wrapper<BXVector<l1t::HGCalTower> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR(void *p) {
      delete ((::edm::Wrapper<BXVector<l1t::HGCalTower> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR(void *p) {
      delete [] ((::edm::Wrapper<BXVector<l1t::HGCalTower> >*)p);
   }
   static void destruct_edmcLcLWrapperlEBXVectorlEl1tcLcLHGCalTowergRsPgR(void *p) {
      typedef ::edm::Wrapper<BXVector<l1t::HGCalTower> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<BXVector<l1t::HGCalTower> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > > : new ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >[nElements] : new ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > > : new ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >[nElements] : new ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigicOedmcLcLrefhelpercLcLFindUsingAdvancelEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRcOl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > > : new ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >[nElements] : new ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCFETriggerDigi> : new ::edm::Ptr<l1t::HGCFETriggerDigi>;
   }
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCFETriggerDigi>[nElements] : new ::edm::Ptr<l1t::HGCFETriggerDigi>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR(void *p) {
      delete ((::edm::Ptr<l1t::HGCFETriggerDigi>*)p);
   }
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR(void *p) {
      delete [] ((::edm::Ptr<l1t::HGCFETriggerDigi>*)p);
   }
   static void destruct_edmcLcLPtrlEl1tcLcLHGCFETriggerDigigR(void *p) {
      typedef ::edm::Ptr<l1t::HGCFETriggerDigi> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<l1t::HGCFETriggerDigi>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCalTriggerCell> : new ::edm::Ptr<l1t::HGCalTriggerCell>;
   }
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCalTriggerCell>[nElements] : new ::edm::Ptr<l1t::HGCalTriggerCell>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR(void *p) {
      delete ((::edm::Ptr<l1t::HGCalTriggerCell>*)p);
   }
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR(void *p) {
      delete [] ((::edm::Ptr<l1t::HGCalTriggerCell>*)p);
   }
   static void destruct_edmcLcLPtrlEl1tcLcLHGCalTriggerCellgR(void *p) {
      typedef ::edm::Ptr<l1t::HGCalTriggerCell> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<l1t::HGCalTriggerCell>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEl1tcLcLHGCalClustergR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCalCluster> : new ::edm::Ptr<l1t::HGCalCluster>;
   }
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCalClustergR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCalCluster>[nElements] : new ::edm::Ptr<l1t::HGCalCluster>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEl1tcLcLHGCalClustergR(void *p) {
      delete ((::edm::Ptr<l1t::HGCalCluster>*)p);
   }
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCalClustergR(void *p) {
      delete [] ((::edm::Ptr<l1t::HGCalCluster>*)p);
   }
   static void destruct_edmcLcLPtrlEl1tcLcLHGCalClustergR(void *p) {
      typedef ::edm::Ptr<l1t::HGCalCluster> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<l1t::HGCalCluster>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCalTowerMap> : new ::edm::Ptr<l1t::HGCalTowerMap>;
   }
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCalTowerMap>[nElements] : new ::edm::Ptr<l1t::HGCalTowerMap>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR(void *p) {
      delete ((::edm::Ptr<l1t::HGCalTowerMap>*)p);
   }
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR(void *p) {
      delete [] ((::edm::Ptr<l1t::HGCalTowerMap>*)p);
   }
   static void destruct_edmcLcLPtrlEl1tcLcLHGCalTowerMapgR(void *p) {
      typedef ::edm::Ptr<l1t::HGCalTowerMap> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<l1t::HGCalTowerMap>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCalConcentratorData> : new ::edm::Ptr<l1t::HGCalConcentratorData>;
   }
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCalConcentratorData>[nElements] : new ::edm::Ptr<l1t::HGCalConcentratorData>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      delete ((::edm::Ptr<l1t::HGCalConcentratorData>*)p);
   }
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      delete [] ((::edm::Ptr<l1t::HGCalConcentratorData>*)p);
   }
   static void destruct_edmcLcLPtrlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      typedef ::edm::Ptr<l1t::HGCalConcentratorData> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<l1t::HGCalConcentratorData>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCalTriggerSums> : new ::edm::Ptr<l1t::HGCalTriggerSums>;
   }
   static void *newArray_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Ptr<l1t::HGCalTriggerSums>[nElements] : new ::edm::Ptr<l1t::HGCalTriggerSums>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      delete ((::edm::Ptr<l1t::HGCalTriggerSums>*)p);
   }
   static void deleteArray_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      delete [] ((::edm::Ptr<l1t::HGCalTriggerSums>*)p);
   }
   static void destruct_edmcLcLPtrlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      typedef ::edm::Ptr<l1t::HGCalTriggerSums> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<l1t::HGCalTriggerSums>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::PtrVector<l1t::HGCalTowerMap> : new ::edm::PtrVector<l1t::HGCalTowerMap>;
   }
   static void *newArray_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::PtrVector<l1t::HGCalTowerMap>[nElements] : new ::edm::PtrVector<l1t::HGCalTowerMap>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      delete ((::edm::PtrVector<l1t::HGCalTowerMap>*)p);
   }
   static void deleteArray_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      delete [] ((::edm::PtrVector<l1t::HGCalTowerMap>*)p);
   }
   static void destruct_edmcLcLPtrVectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      typedef ::edm::PtrVector<l1t::HGCalTowerMap> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::PtrVector<l1t::HGCalTowerMap>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > : new ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >;
   }
   static void *newArray_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >[nElements] : new ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      delete ((::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >*)p);
   }
   static void deleteArray_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      delete [] ((::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >*)p);
   }
   static void destruct_edmcLcLSortedCollectionlEl1tcLcLHGCFETriggerDigicOedmcLcLStrictWeakOrderinglEl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      typedef ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BXVectorlEl1tcLcLHGCalTriggerCellgR(void *p) {
      return  p ? new(p) ::BXVector<l1t::HGCalTriggerCell> : new ::BXVector<l1t::HGCalTriggerCell>;
   }
   static void *newArray_BXVectorlEl1tcLcLHGCalTriggerCellgR(Long_t nElements, void *p) {
      return p ? new(p) ::BXVector<l1t::HGCalTriggerCell>[nElements] : new ::BXVector<l1t::HGCalTriggerCell>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BXVectorlEl1tcLcLHGCalTriggerCellgR(void *p) {
      delete ((::BXVector<l1t::HGCalTriggerCell>*)p);
   }
   static void deleteArray_BXVectorlEl1tcLcLHGCalTriggerCellgR(void *p) {
      delete [] ((::BXVector<l1t::HGCalTriggerCell>*)p);
   }
   static void destruct_BXVectorlEl1tcLcLHGCalTriggerCellgR(void *p) {
      typedef ::BXVector<l1t::HGCalTriggerCell> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BXVector<l1t::HGCalTriggerCell>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BXVectorlEl1tcLcLHGCalClustergR(void *p) {
      return  p ? new(p) ::BXVector<l1t::HGCalCluster> : new ::BXVector<l1t::HGCalCluster>;
   }
   static void *newArray_BXVectorlEl1tcLcLHGCalClustergR(Long_t nElements, void *p) {
      return p ? new(p) ::BXVector<l1t::HGCalCluster>[nElements] : new ::BXVector<l1t::HGCalCluster>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BXVectorlEl1tcLcLHGCalClustergR(void *p) {
      delete ((::BXVector<l1t::HGCalCluster>*)p);
   }
   static void deleteArray_BXVectorlEl1tcLcLHGCalClustergR(void *p) {
      delete [] ((::BXVector<l1t::HGCalCluster>*)p);
   }
   static void destruct_BXVectorlEl1tcLcLHGCalClustergR(void *p) {
      typedef ::BXVector<l1t::HGCalCluster> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BXVector<l1t::HGCalCluster>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BXVectorlEl1tcLcLHGCalMulticlustergR(void *p) {
      return  p ? new(p) ::BXVector<l1t::HGCalMulticluster> : new ::BXVector<l1t::HGCalMulticluster>;
   }
   static void *newArray_BXVectorlEl1tcLcLHGCalMulticlustergR(Long_t nElements, void *p) {
      return p ? new(p) ::BXVector<l1t::HGCalMulticluster>[nElements] : new ::BXVector<l1t::HGCalMulticluster>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BXVectorlEl1tcLcLHGCalMulticlustergR(void *p) {
      delete ((::BXVector<l1t::HGCalMulticluster>*)p);
   }
   static void deleteArray_BXVectorlEl1tcLcLHGCalMulticlustergR(void *p) {
      delete [] ((::BXVector<l1t::HGCalMulticluster>*)p);
   }
   static void destruct_BXVectorlEl1tcLcLHGCalMulticlustergR(void *p) {
      typedef ::BXVector<l1t::HGCalMulticluster> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BXVector<l1t::HGCalMulticluster>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BXVectorlEl1tcLcLHGCalTowergR(void *p) {
      return  p ? new(p) ::BXVector<l1t::HGCalTower> : new ::BXVector<l1t::HGCalTower>;
   }
   static void *newArray_BXVectorlEl1tcLcLHGCalTowergR(Long_t nElements, void *p) {
      return p ? new(p) ::BXVector<l1t::HGCalTower>[nElements] : new ::BXVector<l1t::HGCalTower>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BXVectorlEl1tcLcLHGCalTowergR(void *p) {
      delete ((::BXVector<l1t::HGCalTower>*)p);
   }
   static void deleteArray_BXVectorlEl1tcLcLHGCalTowergR(void *p) {
      delete [] ((::BXVector<l1t::HGCalTower>*)p);
   }
   static void destruct_BXVectorlEl1tcLcLHGCalTowergR(void *p) {
      typedef ::BXVector<l1t::HGCalTower> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BXVector<l1t::HGCalTower>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BXVectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      return  p ? new(p) ::BXVector<l1t::HGCalTowerMap> : new ::BXVector<l1t::HGCalTowerMap>;
   }
   static void *newArray_BXVectorlEl1tcLcLHGCalTowerMapgR(Long_t nElements, void *p) {
      return p ? new(p) ::BXVector<l1t::HGCalTowerMap>[nElements] : new ::BXVector<l1t::HGCalTowerMap>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BXVectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      delete ((::BXVector<l1t::HGCalTowerMap>*)p);
   }
   static void deleteArray_BXVectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      delete [] ((::BXVector<l1t::HGCalTowerMap>*)p);
   }
   static void destruct_BXVectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      typedef ::BXVector<l1t::HGCalTowerMap> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BXVector<l1t::HGCalTowerMap>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BXVectorlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      return  p ? new(p) ::BXVector<l1t::HGCalTriggerSums> : new ::BXVector<l1t::HGCalTriggerSums>;
   }
   static void *newArray_BXVectorlEl1tcLcLHGCalTriggerSumsgR(Long_t nElements, void *p) {
      return p ? new(p) ::BXVector<l1t::HGCalTriggerSums>[nElements] : new ::BXVector<l1t::HGCalTriggerSums>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BXVectorlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      delete ((::BXVector<l1t::HGCalTriggerSums>*)p);
   }
   static void deleteArray_BXVectorlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      delete [] ((::BXVector<l1t::HGCalTriggerSums>*)p);
   }
   static void destruct_BXVectorlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      typedef ::BXVector<l1t::HGCalTriggerSums> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BXVector<l1t::HGCalTriggerSums>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BXVectorlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      return  p ? new(p) ::BXVector<l1t::HGCalConcentratorData> : new ::BXVector<l1t::HGCalConcentratorData>;
   }
   static void *newArray_BXVectorlEl1tcLcLHGCalConcentratorDatagR(Long_t nElements, void *p) {
      return p ? new(p) ::BXVector<l1t::HGCalConcentratorData>[nElements] : new ::BXVector<l1t::HGCalConcentratorData>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BXVectorlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      delete ((::BXVector<l1t::HGCalConcentratorData>*)p);
   }
   static void deleteArray_BXVectorlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      delete [] ((::BXVector<l1t::HGCalConcentratorData>*)p);
   }
   static void destruct_BXVectorlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      typedef ::BXVector<l1t::HGCalConcentratorData> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BXVector<l1t::HGCalConcentratorData>

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalTriggerCell(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalTriggerCell : new ::l1t::HGCalTriggerCell;
   }
   static void *newArray_l1tcLcLHGCalTriggerCell(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalTriggerCell[nElements] : new ::l1t::HGCalTriggerCell[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalTriggerCell(void *p) {
      delete ((::l1t::HGCalTriggerCell*)p);
   }
   static void deleteArray_l1tcLcLHGCalTriggerCell(void *p) {
      delete [] ((::l1t::HGCalTriggerCell*)p);
   }
   static void destruct_l1tcLcLHGCalTriggerCell(void *p) {
      typedef ::l1t::HGCalTriggerCell current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalTriggerCell

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalClusterT<l1t::HGCalTriggerCell> : new ::l1t::HGCalClusterT<l1t::HGCalTriggerCell>;
   }
   static void *newArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalClusterT<l1t::HGCalTriggerCell>[nElements] : new ::l1t::HGCalClusterT<l1t::HGCalTriggerCell>[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR(void *p) {
      delete ((::l1t::HGCalClusterT<l1t::HGCalTriggerCell>*)p);
   }
   static void deleteArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR(void *p) {
      delete [] ((::l1t::HGCalClusterT<l1t::HGCalTriggerCell>*)p);
   }
   static void destruct_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerCellgR(void *p) {
      typedef ::l1t::HGCalClusterT<l1t::HGCalTriggerCell> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalClusterT<l1t::HGCalTriggerCell>

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalClusterT<l1t::HGCalCluster> : new ::l1t::HGCalClusterT<l1t::HGCalCluster>;
   }
   static void *newArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalClusterT<l1t::HGCalCluster>[nElements] : new ::l1t::HGCalClusterT<l1t::HGCalCluster>[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR(void *p) {
      delete ((::l1t::HGCalClusterT<l1t::HGCalCluster>*)p);
   }
   static void deleteArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR(void *p) {
      delete [] ((::l1t::HGCalClusterT<l1t::HGCalCluster>*)p);
   }
   static void destruct_l1tcLcLHGCalClusterTlEl1tcLcLHGCalClustergR(void *p) {
      typedef ::l1t::HGCalClusterT<l1t::HGCalCluster> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalClusterT<l1t::HGCalCluster>

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalClusterT<l1t::HGCalTriggerSums> : new ::l1t::HGCalClusterT<l1t::HGCalTriggerSums>;
   }
   static void *newArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalClusterT<l1t::HGCalTriggerSums>[nElements] : new ::l1t::HGCalClusterT<l1t::HGCalTriggerSums>[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      delete ((::l1t::HGCalClusterT<l1t::HGCalTriggerSums>*)p);
   }
   static void deleteArray_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      delete [] ((::l1t::HGCalClusterT<l1t::HGCalTriggerSums>*)p);
   }
   static void destruct_l1tcLcLHGCalClusterTlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      typedef ::l1t::HGCalClusterT<l1t::HGCalTriggerSums> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalClusterT<l1t::HGCalTriggerSums>

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalCluster(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalCluster : new ::l1t::HGCalCluster;
   }
   static void *newArray_l1tcLcLHGCalCluster(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalCluster[nElements] : new ::l1t::HGCalCluster[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalCluster(void *p) {
      delete ((::l1t::HGCalCluster*)p);
   }
   static void deleteArray_l1tcLcLHGCalCluster(void *p) {
      delete [] ((::l1t::HGCalCluster*)p);
   }
   static void destruct_l1tcLcLHGCalCluster(void *p) {
      typedef ::l1t::HGCalCluster current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalCluster

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalMulticluster(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalMulticluster : new ::l1t::HGCalMulticluster;
   }
   static void *newArray_l1tcLcLHGCalMulticluster(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalMulticluster[nElements] : new ::l1t::HGCalMulticluster[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalMulticluster(void *p) {
      delete ((::l1t::HGCalMulticluster*)p);
   }
   static void deleteArray_l1tcLcLHGCalMulticluster(void *p) {
      delete [] ((::l1t::HGCalMulticluster*)p);
   }
   static void destruct_l1tcLcLHGCalMulticluster(void *p) {
      typedef ::l1t::HGCalMulticluster current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalMulticluster

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalTowerID(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalTowerID : new ::l1t::HGCalTowerID;
   }
   static void *newArray_l1tcLcLHGCalTowerID(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalTowerID[nElements] : new ::l1t::HGCalTowerID[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalTowerID(void *p) {
      delete ((::l1t::HGCalTowerID*)p);
   }
   static void deleteArray_l1tcLcLHGCalTowerID(void *p) {
      delete [] ((::l1t::HGCalTowerID*)p);
   }
   static void destruct_l1tcLcLHGCalTowerID(void *p) {
      typedef ::l1t::HGCalTowerID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalTowerID

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalTower(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalTower : new ::l1t::HGCalTower;
   }
   static void *newArray_l1tcLcLHGCalTower(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalTower[nElements] : new ::l1t::HGCalTower[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalTower(void *p) {
      delete ((::l1t::HGCalTower*)p);
   }
   static void deleteArray_l1tcLcLHGCalTower(void *p) {
      delete [] ((::l1t::HGCalTower*)p);
   }
   static void destruct_l1tcLcLHGCalTower(void *p) {
      typedef ::l1t::HGCalTower current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalTower

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalTowerMap(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalTowerMap : new ::l1t::HGCalTowerMap;
   }
   static void *newArray_l1tcLcLHGCalTowerMap(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalTowerMap[nElements] : new ::l1t::HGCalTowerMap[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalTowerMap(void *p) {
      delete ((::l1t::HGCalTowerMap*)p);
   }
   static void deleteArray_l1tcLcLHGCalTowerMap(void *p) {
      delete [] ((::l1t::HGCalTowerMap*)p);
   }
   static void destruct_l1tcLcLHGCalTowerMap(void *p) {
      typedef ::l1t::HGCalTowerMap current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalTowerMap

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalTriggerSums(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalTriggerSums : new ::l1t::HGCalTriggerSums;
   }
   static void *newArray_l1tcLcLHGCalTriggerSums(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalTriggerSums[nElements] : new ::l1t::HGCalTriggerSums[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalTriggerSums(void *p) {
      delete ((::l1t::HGCalTriggerSums*)p);
   }
   static void deleteArray_l1tcLcLHGCalTriggerSums(void *p) {
      delete [] ((::l1t::HGCalTriggerSums*)p);
   }
   static void destruct_l1tcLcLHGCalTriggerSums(void *p) {
      typedef ::l1t::HGCalTriggerSums current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalTriggerSums

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLHGCalConcentratorData(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalConcentratorData : new ::l1t::HGCalConcentratorData;
   }
   static void *newArray_l1tcLcLHGCalConcentratorData(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::HGCalConcentratorData[nElements] : new ::l1t::HGCalConcentratorData[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLHGCalConcentratorData(void *p) {
      delete ((::l1t::HGCalConcentratorData*)p);
   }
   static void deleteArray_l1tcLcLHGCalConcentratorData(void *p) {
      delete [] ((::l1t::HGCalConcentratorData*)p);
   }
   static void destruct_l1tcLcLHGCalConcentratorData(void *p) {
      typedef ::l1t::HGCalConcentratorData current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::HGCalConcentratorData

namespace ROOT {
   // Wrappers around operator new
   static void *new_l1tcLcLClusterShapes(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::ClusterShapes : new ::l1t::ClusterShapes;
   }
   static void *newArray_l1tcLcLClusterShapes(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::l1t::ClusterShapes[nElements] : new ::l1t::ClusterShapes[nElements];
   }
   // Wrapper around operator delete
   static void delete_l1tcLcLClusterShapes(void *p) {
      delete ((::l1t::ClusterShapes*)p);
   }
   static void deleteArray_l1tcLcLClusterShapes(void *p) {
      delete [] ((::l1t::ClusterShapes*)p);
   }
   static void destruct_l1tcLcLClusterShapes(void *p) {
      typedef ::l1t::ClusterShapes current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::l1t::ClusterShapes

namespace ROOT {
   static TClass *vectorlEl1tcLcLHGCalTriggerSumsgR_Dictionary();
   static void vectorlEl1tcLcLHGCalTriggerSumsgR_TClassManip(TClass*);
   static void *new_vectorlEl1tcLcLHGCalTriggerSumsgR(void *p = 0);
   static void *newArray_vectorlEl1tcLcLHGCalTriggerSumsgR(Long_t size, void *p);
   static void delete_vectorlEl1tcLcLHGCalTriggerSumsgR(void *p);
   static void deleteArray_vectorlEl1tcLcLHGCalTriggerSumsgR(void *p);
   static void destruct_vectorlEl1tcLcLHGCalTriggerSumsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<l1t::HGCalTriggerSums>*)
   {
      vector<l1t::HGCalTriggerSums> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<l1t::HGCalTriggerSums>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<l1t::HGCalTriggerSums>", -2, "vector", 389,
                  typeid(vector<l1t::HGCalTriggerSums>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEl1tcLcLHGCalTriggerSumsgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<l1t::HGCalTriggerSums>) );
      instance.SetNew(&new_vectorlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetNewArray(&newArray_vectorlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDelete(&delete_vectorlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDeleteArray(&deleteArray_vectorlEl1tcLcLHGCalTriggerSumsgR);
      instance.SetDestructor(&destruct_vectorlEl1tcLcLHGCalTriggerSumsgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<l1t::HGCalTriggerSums> >()));

      ::ROOT::AddClassAlternate("vector<l1t::HGCalTriggerSums>","std::vector<l1t::HGCalTriggerSums, std::allocator<l1t::HGCalTriggerSums> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<l1t::HGCalTriggerSums>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEl1tcLcLHGCalTriggerSumsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<l1t::HGCalTriggerSums>*)0x0)->GetClass();
      vectorlEl1tcLcLHGCalTriggerSumsgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEl1tcLcLHGCalTriggerSumsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalTriggerSums> : new vector<l1t::HGCalTriggerSums>;
   }
   static void *newArray_vectorlEl1tcLcLHGCalTriggerSumsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalTriggerSums>[nElements] : new vector<l1t::HGCalTriggerSums>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      delete ((vector<l1t::HGCalTriggerSums>*)p);
   }
   static void deleteArray_vectorlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      delete [] ((vector<l1t::HGCalTriggerSums>*)p);
   }
   static void destruct_vectorlEl1tcLcLHGCalTriggerSumsgR(void *p) {
      typedef vector<l1t::HGCalTriggerSums> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<l1t::HGCalTriggerSums>

namespace ROOT {
   static TClass *vectorlEl1tcLcLHGCalTriggerCellgR_Dictionary();
   static void vectorlEl1tcLcLHGCalTriggerCellgR_TClassManip(TClass*);
   static void *new_vectorlEl1tcLcLHGCalTriggerCellgR(void *p = 0);
   static void *newArray_vectorlEl1tcLcLHGCalTriggerCellgR(Long_t size, void *p);
   static void delete_vectorlEl1tcLcLHGCalTriggerCellgR(void *p);
   static void deleteArray_vectorlEl1tcLcLHGCalTriggerCellgR(void *p);
   static void destruct_vectorlEl1tcLcLHGCalTriggerCellgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<l1t::HGCalTriggerCell>*)
   {
      vector<l1t::HGCalTriggerCell> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<l1t::HGCalTriggerCell>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<l1t::HGCalTriggerCell>", -2, "vector", 389,
                  typeid(vector<l1t::HGCalTriggerCell>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEl1tcLcLHGCalTriggerCellgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<l1t::HGCalTriggerCell>) );
      instance.SetNew(&new_vectorlEl1tcLcLHGCalTriggerCellgR);
      instance.SetNewArray(&newArray_vectorlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDelete(&delete_vectorlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDeleteArray(&deleteArray_vectorlEl1tcLcLHGCalTriggerCellgR);
      instance.SetDestructor(&destruct_vectorlEl1tcLcLHGCalTriggerCellgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<l1t::HGCalTriggerCell> >()));

      ::ROOT::AddClassAlternate("vector<l1t::HGCalTriggerCell>","std::vector<l1t::HGCalTriggerCell, std::allocator<l1t::HGCalTriggerCell> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<l1t::HGCalTriggerCell>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEl1tcLcLHGCalTriggerCellgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<l1t::HGCalTriggerCell>*)0x0)->GetClass();
      vectorlEl1tcLcLHGCalTriggerCellgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEl1tcLcLHGCalTriggerCellgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEl1tcLcLHGCalTriggerCellgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalTriggerCell> : new vector<l1t::HGCalTriggerCell>;
   }
   static void *newArray_vectorlEl1tcLcLHGCalTriggerCellgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalTriggerCell>[nElements] : new vector<l1t::HGCalTriggerCell>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEl1tcLcLHGCalTriggerCellgR(void *p) {
      delete ((vector<l1t::HGCalTriggerCell>*)p);
   }
   static void deleteArray_vectorlEl1tcLcLHGCalTriggerCellgR(void *p) {
      delete [] ((vector<l1t::HGCalTriggerCell>*)p);
   }
   static void destruct_vectorlEl1tcLcLHGCalTriggerCellgR(void *p) {
      typedef vector<l1t::HGCalTriggerCell> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<l1t::HGCalTriggerCell>

namespace ROOT {
   static TClass *vectorlEl1tcLcLHGCalTowerMapgR_Dictionary();
   static void vectorlEl1tcLcLHGCalTowerMapgR_TClassManip(TClass*);
   static void *new_vectorlEl1tcLcLHGCalTowerMapgR(void *p = 0);
   static void *newArray_vectorlEl1tcLcLHGCalTowerMapgR(Long_t size, void *p);
   static void delete_vectorlEl1tcLcLHGCalTowerMapgR(void *p);
   static void deleteArray_vectorlEl1tcLcLHGCalTowerMapgR(void *p);
   static void destruct_vectorlEl1tcLcLHGCalTowerMapgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<l1t::HGCalTowerMap>*)
   {
      vector<l1t::HGCalTowerMap> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<l1t::HGCalTowerMap>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<l1t::HGCalTowerMap>", -2, "vector", 389,
                  typeid(vector<l1t::HGCalTowerMap>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEl1tcLcLHGCalTowerMapgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<l1t::HGCalTowerMap>) );
      instance.SetNew(&new_vectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetNewArray(&newArray_vectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetDelete(&delete_vectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetDeleteArray(&deleteArray_vectorlEl1tcLcLHGCalTowerMapgR);
      instance.SetDestructor(&destruct_vectorlEl1tcLcLHGCalTowerMapgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<l1t::HGCalTowerMap> >()));

      ::ROOT::AddClassAlternate("vector<l1t::HGCalTowerMap>","std::vector<l1t::HGCalTowerMap, std::allocator<l1t::HGCalTowerMap> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<l1t::HGCalTowerMap>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEl1tcLcLHGCalTowerMapgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<l1t::HGCalTowerMap>*)0x0)->GetClass();
      vectorlEl1tcLcLHGCalTowerMapgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEl1tcLcLHGCalTowerMapgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalTowerMap> : new vector<l1t::HGCalTowerMap>;
   }
   static void *newArray_vectorlEl1tcLcLHGCalTowerMapgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalTowerMap>[nElements] : new vector<l1t::HGCalTowerMap>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      delete ((vector<l1t::HGCalTowerMap>*)p);
   }
   static void deleteArray_vectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      delete [] ((vector<l1t::HGCalTowerMap>*)p);
   }
   static void destruct_vectorlEl1tcLcLHGCalTowerMapgR(void *p) {
      typedef vector<l1t::HGCalTowerMap> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<l1t::HGCalTowerMap>

namespace ROOT {
   static TClass *vectorlEl1tcLcLHGCalTowergR_Dictionary();
   static void vectorlEl1tcLcLHGCalTowergR_TClassManip(TClass*);
   static void *new_vectorlEl1tcLcLHGCalTowergR(void *p = 0);
   static void *newArray_vectorlEl1tcLcLHGCalTowergR(Long_t size, void *p);
   static void delete_vectorlEl1tcLcLHGCalTowergR(void *p);
   static void deleteArray_vectorlEl1tcLcLHGCalTowergR(void *p);
   static void destruct_vectorlEl1tcLcLHGCalTowergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<l1t::HGCalTower>*)
   {
      vector<l1t::HGCalTower> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<l1t::HGCalTower>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<l1t::HGCalTower>", -2, "vector", 389,
                  typeid(vector<l1t::HGCalTower>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEl1tcLcLHGCalTowergR_Dictionary, isa_proxy, 4,
                  sizeof(vector<l1t::HGCalTower>) );
      instance.SetNew(&new_vectorlEl1tcLcLHGCalTowergR);
      instance.SetNewArray(&newArray_vectorlEl1tcLcLHGCalTowergR);
      instance.SetDelete(&delete_vectorlEl1tcLcLHGCalTowergR);
      instance.SetDeleteArray(&deleteArray_vectorlEl1tcLcLHGCalTowergR);
      instance.SetDestructor(&destruct_vectorlEl1tcLcLHGCalTowergR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<l1t::HGCalTower> >()));

      ::ROOT::AddClassAlternate("vector<l1t::HGCalTower>","std::vector<l1t::HGCalTower, std::allocator<l1t::HGCalTower> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<l1t::HGCalTower>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEl1tcLcLHGCalTowergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<l1t::HGCalTower>*)0x0)->GetClass();
      vectorlEl1tcLcLHGCalTowergR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEl1tcLcLHGCalTowergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEl1tcLcLHGCalTowergR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalTower> : new vector<l1t::HGCalTower>;
   }
   static void *newArray_vectorlEl1tcLcLHGCalTowergR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalTower>[nElements] : new vector<l1t::HGCalTower>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEl1tcLcLHGCalTowergR(void *p) {
      delete ((vector<l1t::HGCalTower>*)p);
   }
   static void deleteArray_vectorlEl1tcLcLHGCalTowergR(void *p) {
      delete [] ((vector<l1t::HGCalTower>*)p);
   }
   static void destruct_vectorlEl1tcLcLHGCalTowergR(void *p) {
      typedef vector<l1t::HGCalTower> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<l1t::HGCalTower>

namespace ROOT {
   static TClass *vectorlEl1tcLcLHGCalMulticlustergR_Dictionary();
   static void vectorlEl1tcLcLHGCalMulticlustergR_TClassManip(TClass*);
   static void *new_vectorlEl1tcLcLHGCalMulticlustergR(void *p = 0);
   static void *newArray_vectorlEl1tcLcLHGCalMulticlustergR(Long_t size, void *p);
   static void delete_vectorlEl1tcLcLHGCalMulticlustergR(void *p);
   static void deleteArray_vectorlEl1tcLcLHGCalMulticlustergR(void *p);
   static void destruct_vectorlEl1tcLcLHGCalMulticlustergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<l1t::HGCalMulticluster>*)
   {
      vector<l1t::HGCalMulticluster> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<l1t::HGCalMulticluster>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<l1t::HGCalMulticluster>", -2, "vector", 389,
                  typeid(vector<l1t::HGCalMulticluster>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEl1tcLcLHGCalMulticlustergR_Dictionary, isa_proxy, 4,
                  sizeof(vector<l1t::HGCalMulticluster>) );
      instance.SetNew(&new_vectorlEl1tcLcLHGCalMulticlustergR);
      instance.SetNewArray(&newArray_vectorlEl1tcLcLHGCalMulticlustergR);
      instance.SetDelete(&delete_vectorlEl1tcLcLHGCalMulticlustergR);
      instance.SetDeleteArray(&deleteArray_vectorlEl1tcLcLHGCalMulticlustergR);
      instance.SetDestructor(&destruct_vectorlEl1tcLcLHGCalMulticlustergR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<l1t::HGCalMulticluster> >()));

      ::ROOT::AddClassAlternate("vector<l1t::HGCalMulticluster>","std::vector<l1t::HGCalMulticluster, std::allocator<l1t::HGCalMulticluster> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<l1t::HGCalMulticluster>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEl1tcLcLHGCalMulticlustergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<l1t::HGCalMulticluster>*)0x0)->GetClass();
      vectorlEl1tcLcLHGCalMulticlustergR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEl1tcLcLHGCalMulticlustergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEl1tcLcLHGCalMulticlustergR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalMulticluster> : new vector<l1t::HGCalMulticluster>;
   }
   static void *newArray_vectorlEl1tcLcLHGCalMulticlustergR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalMulticluster>[nElements] : new vector<l1t::HGCalMulticluster>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEl1tcLcLHGCalMulticlustergR(void *p) {
      delete ((vector<l1t::HGCalMulticluster>*)p);
   }
   static void deleteArray_vectorlEl1tcLcLHGCalMulticlustergR(void *p) {
      delete [] ((vector<l1t::HGCalMulticluster>*)p);
   }
   static void destruct_vectorlEl1tcLcLHGCalMulticlustergR(void *p) {
      typedef vector<l1t::HGCalMulticluster> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<l1t::HGCalMulticluster>

namespace ROOT {
   static TClass *vectorlEl1tcLcLHGCalConcentratorDatagR_Dictionary();
   static void vectorlEl1tcLcLHGCalConcentratorDatagR_TClassManip(TClass*);
   static void *new_vectorlEl1tcLcLHGCalConcentratorDatagR(void *p = 0);
   static void *newArray_vectorlEl1tcLcLHGCalConcentratorDatagR(Long_t size, void *p);
   static void delete_vectorlEl1tcLcLHGCalConcentratorDatagR(void *p);
   static void deleteArray_vectorlEl1tcLcLHGCalConcentratorDatagR(void *p);
   static void destruct_vectorlEl1tcLcLHGCalConcentratorDatagR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<l1t::HGCalConcentratorData>*)
   {
      vector<l1t::HGCalConcentratorData> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<l1t::HGCalConcentratorData>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<l1t::HGCalConcentratorData>", -2, "vector", 389,
                  typeid(vector<l1t::HGCalConcentratorData>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEl1tcLcLHGCalConcentratorDatagR_Dictionary, isa_proxy, 4,
                  sizeof(vector<l1t::HGCalConcentratorData>) );
      instance.SetNew(&new_vectorlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetNewArray(&newArray_vectorlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetDelete(&delete_vectorlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetDeleteArray(&deleteArray_vectorlEl1tcLcLHGCalConcentratorDatagR);
      instance.SetDestructor(&destruct_vectorlEl1tcLcLHGCalConcentratorDatagR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<l1t::HGCalConcentratorData> >()));

      ::ROOT::AddClassAlternate("vector<l1t::HGCalConcentratorData>","std::vector<l1t::HGCalConcentratorData, std::allocator<l1t::HGCalConcentratorData> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<l1t::HGCalConcentratorData>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEl1tcLcLHGCalConcentratorDatagR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<l1t::HGCalConcentratorData>*)0x0)->GetClass();
      vectorlEl1tcLcLHGCalConcentratorDatagR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEl1tcLcLHGCalConcentratorDatagR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalConcentratorData> : new vector<l1t::HGCalConcentratorData>;
   }
   static void *newArray_vectorlEl1tcLcLHGCalConcentratorDatagR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalConcentratorData>[nElements] : new vector<l1t::HGCalConcentratorData>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      delete ((vector<l1t::HGCalConcentratorData>*)p);
   }
   static void deleteArray_vectorlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      delete [] ((vector<l1t::HGCalConcentratorData>*)p);
   }
   static void destruct_vectorlEl1tcLcLHGCalConcentratorDatagR(void *p) {
      typedef vector<l1t::HGCalConcentratorData> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<l1t::HGCalConcentratorData>

namespace ROOT {
   static TClass *vectorlEl1tcLcLHGCalClustergR_Dictionary();
   static void vectorlEl1tcLcLHGCalClustergR_TClassManip(TClass*);
   static void *new_vectorlEl1tcLcLHGCalClustergR(void *p = 0);
   static void *newArray_vectorlEl1tcLcLHGCalClustergR(Long_t size, void *p);
   static void delete_vectorlEl1tcLcLHGCalClustergR(void *p);
   static void deleteArray_vectorlEl1tcLcLHGCalClustergR(void *p);
   static void destruct_vectorlEl1tcLcLHGCalClustergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<l1t::HGCalCluster>*)
   {
      vector<l1t::HGCalCluster> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<l1t::HGCalCluster>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<l1t::HGCalCluster>", -2, "vector", 389,
                  typeid(vector<l1t::HGCalCluster>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEl1tcLcLHGCalClustergR_Dictionary, isa_proxy, 4,
                  sizeof(vector<l1t::HGCalCluster>) );
      instance.SetNew(&new_vectorlEl1tcLcLHGCalClustergR);
      instance.SetNewArray(&newArray_vectorlEl1tcLcLHGCalClustergR);
      instance.SetDelete(&delete_vectorlEl1tcLcLHGCalClustergR);
      instance.SetDeleteArray(&deleteArray_vectorlEl1tcLcLHGCalClustergR);
      instance.SetDestructor(&destruct_vectorlEl1tcLcLHGCalClustergR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<l1t::HGCalCluster> >()));

      ::ROOT::AddClassAlternate("vector<l1t::HGCalCluster>","std::vector<l1t::HGCalCluster, std::allocator<l1t::HGCalCluster> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<l1t::HGCalCluster>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEl1tcLcLHGCalClustergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<l1t::HGCalCluster>*)0x0)->GetClass();
      vectorlEl1tcLcLHGCalClustergR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEl1tcLcLHGCalClustergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEl1tcLcLHGCalClustergR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalCluster> : new vector<l1t::HGCalCluster>;
   }
   static void *newArray_vectorlEl1tcLcLHGCalClustergR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCalCluster>[nElements] : new vector<l1t::HGCalCluster>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEl1tcLcLHGCalClustergR(void *p) {
      delete ((vector<l1t::HGCalCluster>*)p);
   }
   static void deleteArray_vectorlEl1tcLcLHGCalClustergR(void *p) {
      delete [] ((vector<l1t::HGCalCluster>*)p);
   }
   static void destruct_vectorlEl1tcLcLHGCalClustergR(void *p) {
      typedef vector<l1t::HGCalCluster> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<l1t::HGCalCluster>

namespace ROOT {
   static TClass *vectorlEl1tcLcLHGCFETriggerDigigR_Dictionary();
   static void vectorlEl1tcLcLHGCFETriggerDigigR_TClassManip(TClass*);
   static void *new_vectorlEl1tcLcLHGCFETriggerDigigR(void *p = 0);
   static void *newArray_vectorlEl1tcLcLHGCFETriggerDigigR(Long_t size, void *p);
   static void delete_vectorlEl1tcLcLHGCFETriggerDigigR(void *p);
   static void deleteArray_vectorlEl1tcLcLHGCFETriggerDigigR(void *p);
   static void destruct_vectorlEl1tcLcLHGCFETriggerDigigR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<l1t::HGCFETriggerDigi>*)
   {
      vector<l1t::HGCFETriggerDigi> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<l1t::HGCFETriggerDigi>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<l1t::HGCFETriggerDigi>", -2, "vector", 389,
                  typeid(vector<l1t::HGCFETriggerDigi>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEl1tcLcLHGCFETriggerDigigR_Dictionary, isa_proxy, 4,
                  sizeof(vector<l1t::HGCFETriggerDigi>) );
      instance.SetNew(&new_vectorlEl1tcLcLHGCFETriggerDigigR);
      instance.SetNewArray(&newArray_vectorlEl1tcLcLHGCFETriggerDigigR);
      instance.SetDelete(&delete_vectorlEl1tcLcLHGCFETriggerDigigR);
      instance.SetDeleteArray(&deleteArray_vectorlEl1tcLcLHGCFETriggerDigigR);
      instance.SetDestructor(&destruct_vectorlEl1tcLcLHGCFETriggerDigigR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<l1t::HGCFETriggerDigi> >()));

      ::ROOT::AddClassAlternate("vector<l1t::HGCFETriggerDigi>","std::vector<l1t::HGCFETriggerDigi, std::allocator<l1t::HGCFETriggerDigi> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<l1t::HGCFETriggerDigi>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEl1tcLcLHGCFETriggerDigigR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<l1t::HGCFETriggerDigi>*)0x0)->GetClass();
      vectorlEl1tcLcLHGCFETriggerDigigR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEl1tcLcLHGCFETriggerDigigR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEl1tcLcLHGCFETriggerDigigR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCFETriggerDigi> : new vector<l1t::HGCFETriggerDigi>;
   }
   static void *newArray_vectorlEl1tcLcLHGCFETriggerDigigR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<l1t::HGCFETriggerDigi>[nElements] : new vector<l1t::HGCFETriggerDigi>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEl1tcLcLHGCFETriggerDigigR(void *p) {
      delete ((vector<l1t::HGCFETriggerDigi>*)p);
   }
   static void deleteArray_vectorlEl1tcLcLHGCFETriggerDigigR(void *p) {
      delete [] ((vector<l1t::HGCFETriggerDigi>*)p);
   }
   static void destruct_vectorlEl1tcLcLHGCFETriggerDigigR(void *p) {
      typedef vector<l1t::HGCFETriggerDigi> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<l1t::HGCFETriggerDigi>

namespace ROOT {
   static TClass *vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary();
   static void vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p = 0);
   static void *newArray_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(Long_t size, void *p);
   static void delete_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);
   static void deleteArray_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);
   static void destruct_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<edm::PtrVector<l1t::HGCalTriggerSums> >*)
   {
      vector<edm::PtrVector<l1t::HGCalTriggerSums> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<edm::PtrVector<l1t::HGCalTriggerSums> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<edm::PtrVector<l1t::HGCalTriggerSums> >", -2, "vector", 389,
                  typeid(vector<edm::PtrVector<l1t::HGCalTriggerSums> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<edm::PtrVector<l1t::HGCalTriggerSums> >) );
      instance.SetNew(&new_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetNewArray(&newArray_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDelete(&delete_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.SetDestructor(&destruct_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<edm::PtrVector<l1t::HGCalTriggerSums> > >()));

      ::ROOT::AddClassAlternate("vector<edm::PtrVector<l1t::HGCalTriggerSums> >","std::vector<edm::PtrVector<l1t::HGCalTriggerSums>, std::allocator<edm::PtrVector<l1t::HGCalTriggerSums> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<edm::PtrVector<l1t::HGCalTriggerSums> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<edm::PtrVector<l1t::HGCalTriggerSums> >*)0x0)->GetClass();
      vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<edm::PtrVector<l1t::HGCalTriggerSums> > : new vector<edm::PtrVector<l1t::HGCalTriggerSums> >;
   }
   static void *newArray_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<edm::PtrVector<l1t::HGCalTriggerSums> >[nElements] : new vector<edm::PtrVector<l1t::HGCalTriggerSums> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      delete ((vector<edm::PtrVector<l1t::HGCalTriggerSums> >*)p);
   }
   static void deleteArray_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      delete [] ((vector<edm::PtrVector<l1t::HGCalTriggerSums> >*)p);
   }
   static void destruct_vectorlEedmcLcLPtrVectorlEl1tcLcLHGCalTriggerSumsgRsPgR(void *p) {
      typedef vector<edm::PtrVector<l1t::HGCalTriggerSums> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<edm::PtrVector<l1t::HGCalTriggerSums> >

namespace ROOT {
   static TClass *vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary();
   static void vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p = 0);
   static void *newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(Long_t size, void *p);
   static void delete_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);
   static void deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);
   static void destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<edm::Ptr<l1t::HGCalTriggerCell> >*)
   {
      vector<edm::Ptr<l1t::HGCalTriggerCell> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<edm::Ptr<l1t::HGCalTriggerCell> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<edm::Ptr<l1t::HGCalTriggerCell> >", -2, "vector", 389,
                  typeid(vector<edm::Ptr<l1t::HGCalTriggerCell> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<edm::Ptr<l1t::HGCalTriggerCell> >) );
      instance.SetNew(&new_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetNewArray(&newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDelete(&delete_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDestructor(&destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<edm::Ptr<l1t::HGCalTriggerCell> > >()));

      ::ROOT::AddClassAlternate("vector<edm::Ptr<l1t::HGCalTriggerCell> >","std::vector<edm::Ptr<l1t::HGCalTriggerCell>, std::allocator<edm::Ptr<l1t::HGCalTriggerCell> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<edm::Ptr<l1t::HGCalTriggerCell> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<edm::Ptr<l1t::HGCalTriggerCell> >*)0x0)->GetClass();
      vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<edm::Ptr<l1t::HGCalTriggerCell> > : new vector<edm::Ptr<l1t::HGCalTriggerCell> >;
   }
   static void *newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<edm::Ptr<l1t::HGCalTriggerCell> >[nElements] : new vector<edm::Ptr<l1t::HGCalTriggerCell> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      delete ((vector<edm::Ptr<l1t::HGCalTriggerCell> >*)p);
   }
   static void deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      delete [] ((vector<edm::Ptr<l1t::HGCalTriggerCell> >*)p);
   }
   static void destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      typedef vector<edm::Ptr<l1t::HGCalTriggerCell> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<edm::Ptr<l1t::HGCalTriggerCell> >

namespace ROOT {
   static TClass *vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary();
   static void vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(TClass*);
   static void *new_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p = 0);
   static void *newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(Long_t size, void *p);
   static void delete_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);
   static void deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);
   static void destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<edm::Ptr<l1t::HGCalConcentratorData> >*)
   {
      vector<edm::Ptr<l1t::HGCalConcentratorData> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<edm::Ptr<l1t::HGCalConcentratorData> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<edm::Ptr<l1t::HGCalConcentratorData> >", -2, "vector", 389,
                  typeid(vector<edm::Ptr<l1t::HGCalConcentratorData> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<edm::Ptr<l1t::HGCalConcentratorData> >) );
      instance.SetNew(&new_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetNewArray(&newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDelete(&delete_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.SetDestructor(&destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<edm::Ptr<l1t::HGCalConcentratorData> > >()));

      ::ROOT::AddClassAlternate("vector<edm::Ptr<l1t::HGCalConcentratorData> >","std::vector<edm::Ptr<l1t::HGCalConcentratorData>, std::allocator<edm::Ptr<l1t::HGCalConcentratorData> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<edm::Ptr<l1t::HGCalConcentratorData> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<edm::Ptr<l1t::HGCalConcentratorData> >*)0x0)->GetClass();
      vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<edm::Ptr<l1t::HGCalConcentratorData> > : new vector<edm::Ptr<l1t::HGCalConcentratorData> >;
   }
   static void *newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<edm::Ptr<l1t::HGCalConcentratorData> >[nElements] : new vector<edm::Ptr<l1t::HGCalConcentratorData> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      delete ((vector<edm::Ptr<l1t::HGCalConcentratorData> >*)p);
   }
   static void deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      delete [] ((vector<edm::Ptr<l1t::HGCalConcentratorData> >*)p);
   }
   static void destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCalConcentratorDatagRsPgR(void *p) {
      typedef vector<edm::Ptr<l1t::HGCalConcentratorData> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<edm::Ptr<l1t::HGCalConcentratorData> >

namespace ROOT {
   static TClass *vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_Dictionary();
   static void vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_TClassManip(TClass*);
   static void *new_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p = 0);
   static void *newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(Long_t size, void *p);
   static void delete_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p);
   static void deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p);
   static void destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<edm::Ptr<l1t::HGCalCluster> >*)
   {
      vector<edm::Ptr<l1t::HGCalCluster> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<edm::Ptr<l1t::HGCalCluster> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<edm::Ptr<l1t::HGCalCluster> >", -2, "vector", 389,
                  typeid(vector<edm::Ptr<l1t::HGCalCluster> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<edm::Ptr<l1t::HGCalCluster> >) );
      instance.SetNew(&new_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetNewArray(&newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDelete(&delete_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDestructor(&destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<edm::Ptr<l1t::HGCalCluster> > >()));

      ::ROOT::AddClassAlternate("vector<edm::Ptr<l1t::HGCalCluster> >","std::vector<edm::Ptr<l1t::HGCalCluster>, std::allocator<edm::Ptr<l1t::HGCalCluster> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<edm::Ptr<l1t::HGCalCluster> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<edm::Ptr<l1t::HGCalCluster> >*)0x0)->GetClass();
      vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<edm::Ptr<l1t::HGCalCluster> > : new vector<edm::Ptr<l1t::HGCalCluster> >;
   }
   static void *newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<edm::Ptr<l1t::HGCalCluster> >[nElements] : new vector<edm::Ptr<l1t::HGCalCluster> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      delete ((vector<edm::Ptr<l1t::HGCalCluster> >*)p);
   }
   static void deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      delete [] ((vector<edm::Ptr<l1t::HGCalCluster> >*)p);
   }
   static void destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      typedef vector<edm::Ptr<l1t::HGCalCluster> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<edm::Ptr<l1t::HGCalCluster> >

namespace ROOT {
   static TClass *vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR_Dictionary();
   static void vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(TClass*);
   static void *new_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR(void *p = 0);
   static void *newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR(Long_t size, void *p);
   static void delete_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR(void *p);
   static void deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR(void *p);
   static void destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<edm::Ptr<l1t::HGCFETriggerDigi> >*)
   {
      vector<edm::Ptr<l1t::HGCFETriggerDigi> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<edm::Ptr<l1t::HGCFETriggerDigi> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<edm::Ptr<l1t::HGCFETriggerDigi> >", -2, "vector", 389,
                  typeid(vector<edm::Ptr<l1t::HGCFETriggerDigi> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<edm::Ptr<l1t::HGCFETriggerDigi> >) );
      instance.SetNew(&new_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetNewArray(&newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDelete(&delete_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR);
      instance.SetDestructor(&destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<edm::Ptr<l1t::HGCFETriggerDigi> > >()));

      ::ROOT::AddClassAlternate("vector<edm::Ptr<l1t::HGCFETriggerDigi> >","std::vector<edm::Ptr<l1t::HGCFETriggerDigi>, std::allocator<edm::Ptr<l1t::HGCFETriggerDigi> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<edm::Ptr<l1t::HGCFETriggerDigi> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<edm::Ptr<l1t::HGCFETriggerDigi> >*)0x0)->GetClass();
      vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<edm::Ptr<l1t::HGCFETriggerDigi> > : new vector<edm::Ptr<l1t::HGCFETriggerDigi> >;
   }
   static void *newArray_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<edm::Ptr<l1t::HGCFETriggerDigi> >[nElements] : new vector<edm::Ptr<l1t::HGCFETriggerDigi> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      delete ((vector<edm::Ptr<l1t::HGCFETriggerDigi> >*)p);
   }
   static void deleteArray_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      delete [] ((vector<edm::Ptr<l1t::HGCFETriggerDigi> >*)p);
   }
   static void destruct_vectorlEedmcLcLPtrlEl1tcLcLHGCFETriggerDigigRsPgR(void *p) {
      typedef vector<edm::Ptr<l1t::HGCFETriggerDigi> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<edm::Ptr<l1t::HGCFETriggerDigi> >

namespace ROOT {
   static TClass *unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR_Dictionary();
   static void unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR_TClassManip(TClass*);
   static void *new_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR(void *p = 0);
   static void *newArray_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR(Long_t size, void *p);
   static void delete_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR(void *p);
   static void deleteArray_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR(void *p);
   static void destruct_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const unordered_map<unsigned short,l1t::HGCalTower>*)
   {
      unordered_map<unsigned short,l1t::HGCalTower> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(unordered_map<unsigned short,l1t::HGCalTower>));
      static ::ROOT::TGenericClassInfo 
         instance("unordered_map<unsigned short,l1t::HGCalTower>", -2, "unordered_map", 102,
                  typeid(unordered_map<unsigned short,l1t::HGCalTower>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR_Dictionary, isa_proxy, 4,
                  sizeof(unordered_map<unsigned short,l1t::HGCalTower>) );
      instance.SetNew(&new_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR);
      instance.SetNewArray(&newArray_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR);
      instance.SetDelete(&delete_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR);
      instance.SetDeleteArray(&deleteArray_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR);
      instance.SetDestructor(&destruct_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< unordered_map<unsigned short,l1t::HGCalTower> >()));

      ::ROOT::AddClassAlternate("unordered_map<unsigned short,l1t::HGCalTower>","std::unordered_map<unsigned short, l1t::HGCalTower, std::hash<unsigned short>, std::equal_to<unsigned short>, std::allocator<std::pair<unsigned short const, l1t::HGCalTower> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const unordered_map<unsigned short,l1t::HGCalTower>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const unordered_map<unsigned short,l1t::HGCalTower>*)0x0)->GetClass();
      unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR_TClassManip(theClass);
   return theClass;
   }

   static void unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned short,l1t::HGCalTower> : new unordered_map<unsigned short,l1t::HGCalTower>;
   }
   static void *newArray_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned short,l1t::HGCalTower>[nElements] : new unordered_map<unsigned short,l1t::HGCalTower>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR(void *p) {
      delete ((unordered_map<unsigned short,l1t::HGCalTower>*)p);
   }
   static void deleteArray_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR(void *p) {
      delete [] ((unordered_map<unsigned short,l1t::HGCalTower>*)p);
   }
   static void destruct_unordered_maplEunsignedsPshortcOl1tcLcLHGCalTowergR(void *p) {
      typedef unordered_map<unsigned short,l1t::HGCalTower> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class unordered_map<unsigned short,l1t::HGCalTower>

namespace ROOT {
   static TClass *unordered_maplEunsignedsPintcOfloatgR_Dictionary();
   static void unordered_maplEunsignedsPintcOfloatgR_TClassManip(TClass*);
   static void *new_unordered_maplEunsignedsPintcOfloatgR(void *p = 0);
   static void *newArray_unordered_maplEunsignedsPintcOfloatgR(Long_t size, void *p);
   static void delete_unordered_maplEunsignedsPintcOfloatgR(void *p);
   static void deleteArray_unordered_maplEunsignedsPintcOfloatgR(void *p);
   static void destruct_unordered_maplEunsignedsPintcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const unordered_map<unsigned int,float>*)
   {
      unordered_map<unsigned int,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(unordered_map<unsigned int,float>));
      static ::ROOT::TGenericClassInfo 
         instance("unordered_map<unsigned int,float>", -2, "unordered_map", 102,
                  typeid(unordered_map<unsigned int,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &unordered_maplEunsignedsPintcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(unordered_map<unsigned int,float>) );
      instance.SetNew(&new_unordered_maplEunsignedsPintcOfloatgR);
      instance.SetNewArray(&newArray_unordered_maplEunsignedsPintcOfloatgR);
      instance.SetDelete(&delete_unordered_maplEunsignedsPintcOfloatgR);
      instance.SetDeleteArray(&deleteArray_unordered_maplEunsignedsPintcOfloatgR);
      instance.SetDestructor(&destruct_unordered_maplEunsignedsPintcOfloatgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< unordered_map<unsigned int,float> >()));

      ::ROOT::AddClassAlternate("unordered_map<unsigned int,float>","std::unordered_map<unsigned int, float, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<unsigned int const, float> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const unordered_map<unsigned int,float>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unordered_maplEunsignedsPintcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const unordered_map<unsigned int,float>*)0x0)->GetClass();
      unordered_maplEunsignedsPintcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void unordered_maplEunsignedsPintcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_unordered_maplEunsignedsPintcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,float> : new unordered_map<unsigned int,float>;
   }
   static void *newArray_unordered_maplEunsignedsPintcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,float>[nElements] : new unordered_map<unsigned int,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unordered_maplEunsignedsPintcOfloatgR(void *p) {
      delete ((unordered_map<unsigned int,float>*)p);
   }
   static void deleteArray_unordered_maplEunsignedsPintcOfloatgR(void *p) {
      delete [] ((unordered_map<unsigned int,float>*)p);
   }
   static void destruct_unordered_maplEunsignedsPintcOfloatgR(void *p) {
      typedef unordered_map<unsigned int,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class unordered_map<unsigned int,float>

namespace ROOT {
   static TClass *unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary();
   static void unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(TClass*);
   static void *new_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p = 0);
   static void *newArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(Long_t size, void *p);
   static void delete_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);
   static void deleteArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);
   static void destruct_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >*)
   {
      unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >));
      static ::ROOT::TGenericClassInfo 
         instance("unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >", -2, "unordered_map", 102,
                  typeid(unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >) );
      instance.SetNew(&new_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetNewArray(&newArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDelete(&delete_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDeleteArray(&deleteArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.SetDestructor(&destruct_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> > >()));

      ::ROOT::AddClassAlternate("unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >","std::unordered_map<unsigned int, edm::Ptr<l1t::HGCalTriggerCell>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<unsigned int const, edm::Ptr<l1t::HGCalTriggerCell> > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >*)0x0)->GetClass();
      unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> > : new unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >;
   }
   static void *newArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >[nElements] : new unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      delete ((unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >*)p);
   }
   static void deleteArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      delete [] ((unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >*)p);
   }
   static void destruct_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalTriggerCellgRsPgR(void *p) {
      typedef unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class unordered_map<unsigned int,edm::Ptr<l1t::HGCalTriggerCell> >

namespace ROOT {
   static TClass *unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_Dictionary();
   static void unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_TClassManip(TClass*);
   static void *new_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p = 0);
   static void *newArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(Long_t size, void *p);
   static void delete_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p);
   static void deleteArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p);
   static void destruct_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >*)
   {
      unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >));
      static ::ROOT::TGenericClassInfo 
         instance("unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >", -2, "unordered_map", 102,
                  typeid(unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >) );
      instance.SetNew(&new_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetNewArray(&newArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDelete(&delete_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDeleteArray(&deleteArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.SetDestructor(&destruct_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> > >()));

      ::ROOT::AddClassAlternate("unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >","std::unordered_map<unsigned int, edm::Ptr<l1t::HGCalCluster>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<unsigned int const, edm::Ptr<l1t::HGCalCluster> > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >*)0x0)->GetClass();
      unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> > : new unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >;
   }
   static void *newArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >[nElements] : new unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      delete ((unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >*)p);
   }
   static void deleteArray_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      delete [] ((unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >*)p);
   }
   static void destruct_unordered_maplEunsignedsPintcOedmcLcLPtrlEl1tcLcLHGCalClustergRsPgR(void *p) {
      typedef unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class unordered_map<unsigned int,edm::Ptr<l1t::HGCalCluster> >

namespace ROOT {
   static TClass *unordered_maplEunsignedsPintcOdoublegR_Dictionary();
   static void unordered_maplEunsignedsPintcOdoublegR_TClassManip(TClass*);
   static void *new_unordered_maplEunsignedsPintcOdoublegR(void *p = 0);
   static void *newArray_unordered_maplEunsignedsPintcOdoublegR(Long_t size, void *p);
   static void delete_unordered_maplEunsignedsPintcOdoublegR(void *p);
   static void deleteArray_unordered_maplEunsignedsPintcOdoublegR(void *p);
   static void destruct_unordered_maplEunsignedsPintcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const unordered_map<unsigned int,double>*)
   {
      unordered_map<unsigned int,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(unordered_map<unsigned int,double>));
      static ::ROOT::TGenericClassInfo 
         instance("unordered_map<unsigned int,double>", -2, "unordered_map", 102,
                  typeid(unordered_map<unsigned int,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &unordered_maplEunsignedsPintcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(unordered_map<unsigned int,double>) );
      instance.SetNew(&new_unordered_maplEunsignedsPintcOdoublegR);
      instance.SetNewArray(&newArray_unordered_maplEunsignedsPintcOdoublegR);
      instance.SetDelete(&delete_unordered_maplEunsignedsPintcOdoublegR);
      instance.SetDeleteArray(&deleteArray_unordered_maplEunsignedsPintcOdoublegR);
      instance.SetDestructor(&destruct_unordered_maplEunsignedsPintcOdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< unordered_map<unsigned int,double> >()));

      ::ROOT::AddClassAlternate("unordered_map<unsigned int,double>","std::unordered_map<unsigned int, double, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<unsigned int const, double> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const unordered_map<unsigned int,double>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unordered_maplEunsignedsPintcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const unordered_map<unsigned int,double>*)0x0)->GetClass();
      unordered_maplEunsignedsPintcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void unordered_maplEunsignedsPintcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_unordered_maplEunsignedsPintcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,double> : new unordered_map<unsigned int,double>;
   }
   static void *newArray_unordered_maplEunsignedsPintcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,double>[nElements] : new unordered_map<unsigned int,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unordered_maplEunsignedsPintcOdoublegR(void *p) {
      delete ((unordered_map<unsigned int,double>*)p);
   }
   static void deleteArray_unordered_maplEunsignedsPintcOdoublegR(void *p) {
      delete [] ((unordered_map<unsigned int,double>*)p);
   }
   static void destruct_unordered_maplEunsignedsPintcOdoublegR(void *p) {
      typedef unordered_map<unsigned int,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class unordered_map<unsigned int,double>

namespace ROOT {
   static TClass *unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR_Dictionary();
   static void unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR_TClassManip(TClass*);
   static void *new_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR(void *p = 0);
   static void *newArray_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR(Long_t size, void *p);
   static void delete_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR(void *p);
   static void deleteArray_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR(void *p);
   static void destruct_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const unordered_map<unsigned int,array<float,48> >*)
   {
      unordered_map<unsigned int,array<float,48> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(unordered_map<unsigned int,array<float,48> >));
      static ::ROOT::TGenericClassInfo 
         instance("unordered_map<unsigned int,array<float,48> >", -2, "unordered_map", 102,
                  typeid(unordered_map<unsigned int,array<float,48> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(unordered_map<unsigned int,array<float,48> >) );
      instance.SetNew(&new_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR);
      instance.SetNewArray(&newArray_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR);
      instance.SetDelete(&delete_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR);
      instance.SetDeleteArray(&deleteArray_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR);
      instance.SetDestructor(&destruct_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< unordered_map<unsigned int,array<float,48> > >()));

      ::ROOT::AddClassAlternate("unordered_map<unsigned int,array<float,48> >","std::unordered_map<unsigned int, std::array<float, 48ul>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<unsigned int const, std::array<float, 48ul> > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const unordered_map<unsigned int,array<float,48> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const unordered_map<unsigned int,array<float,48> >*)0x0)->GetClass();
      unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,array<float,48> > : new unordered_map<unsigned int,array<float,48> >;
   }
   static void *newArray_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,array<float,48> >[nElements] : new unordered_map<unsigned int,array<float,48> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR(void *p) {
      delete ((unordered_map<unsigned int,array<float,48> >*)p);
   }
   static void deleteArray_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR(void *p) {
      delete [] ((unordered_map<unsigned int,array<float,48> >*)p);
   }
   static void destruct_unordered_maplEunsignedsPintcOarraylEfloatcO48gRsPgR(void *p) {
      typedef unordered_map<unsigned int,array<float,48> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class unordered_map<unsigned int,array<float,48> >

namespace ROOT {
   static TClass *unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR_Dictionary();
   static void unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR_TClassManip(TClass*);
   static void *new_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR(void *p = 0);
   static void *newArray_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR(Long_t size, void *p);
   static void delete_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR(void *p);
   static void deleteArray_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR(void *p);
   static void destruct_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const unordered_map<unsigned int,array<float,16> >*)
   {
      unordered_map<unsigned int,array<float,16> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(unordered_map<unsigned int,array<float,16> >));
      static ::ROOT::TGenericClassInfo 
         instance("unordered_map<unsigned int,array<float,16> >", -2, "unordered_map", 102,
                  typeid(unordered_map<unsigned int,array<float,16> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(unordered_map<unsigned int,array<float,16> >) );
      instance.SetNew(&new_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR);
      instance.SetNewArray(&newArray_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR);
      instance.SetDelete(&delete_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR);
      instance.SetDeleteArray(&deleteArray_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR);
      instance.SetDestructor(&destruct_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< unordered_map<unsigned int,array<float,16> > >()));

      ::ROOT::AddClassAlternate("unordered_map<unsigned int,array<float,16> >","std::unordered_map<unsigned int, std::array<float, 16ul>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<unsigned int const, std::array<float, 16ul> > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const unordered_map<unsigned int,array<float,16> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const unordered_map<unsigned int,array<float,16> >*)0x0)->GetClass();
      unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,array<float,16> > : new unordered_map<unsigned int,array<float,16> >;
   }
   static void *newArray_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<unsigned int,array<float,16> >[nElements] : new unordered_map<unsigned int,array<float,16> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR(void *p) {
      delete ((unordered_map<unsigned int,array<float,16> >*)p);
   }
   static void deleteArray_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR(void *p) {
      delete [] ((unordered_map<unsigned int,array<float,16> >*)p);
   }
   static void destruct_unordered_maplEunsignedsPintcOarraylEfloatcO16gRsPgR(void *p) {
      typedef unordered_map<unsigned int,array<float,16> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class unordered_map<unsigned int,array<float,16> >

namespace ROOT {
   static TClass *unordered_maplEintcOl1tcLcLHGCalTowergR_Dictionary();
   static void unordered_maplEintcOl1tcLcLHGCalTowergR_TClassManip(TClass*);
   static void *new_unordered_maplEintcOl1tcLcLHGCalTowergR(void *p = 0);
   static void *newArray_unordered_maplEintcOl1tcLcLHGCalTowergR(Long_t size, void *p);
   static void delete_unordered_maplEintcOl1tcLcLHGCalTowergR(void *p);
   static void deleteArray_unordered_maplEintcOl1tcLcLHGCalTowergR(void *p);
   static void destruct_unordered_maplEintcOl1tcLcLHGCalTowergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const unordered_map<int,l1t::HGCalTower>*)
   {
      unordered_map<int,l1t::HGCalTower> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(unordered_map<int,l1t::HGCalTower>));
      static ::ROOT::TGenericClassInfo 
         instance("unordered_map<int,l1t::HGCalTower>", -2, "unordered_map", 102,
                  typeid(unordered_map<int,l1t::HGCalTower>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &unordered_maplEintcOl1tcLcLHGCalTowergR_Dictionary, isa_proxy, 4,
                  sizeof(unordered_map<int,l1t::HGCalTower>) );
      instance.SetNew(&new_unordered_maplEintcOl1tcLcLHGCalTowergR);
      instance.SetNewArray(&newArray_unordered_maplEintcOl1tcLcLHGCalTowergR);
      instance.SetDelete(&delete_unordered_maplEintcOl1tcLcLHGCalTowergR);
      instance.SetDeleteArray(&deleteArray_unordered_maplEintcOl1tcLcLHGCalTowergR);
      instance.SetDestructor(&destruct_unordered_maplEintcOl1tcLcLHGCalTowergR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< unordered_map<int,l1t::HGCalTower> >()));

      ::ROOT::AddClassAlternate("unordered_map<int,l1t::HGCalTower>","std::unordered_map<int, l1t::HGCalTower, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, l1t::HGCalTower> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const unordered_map<int,l1t::HGCalTower>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unordered_maplEintcOl1tcLcLHGCalTowergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const unordered_map<int,l1t::HGCalTower>*)0x0)->GetClass();
      unordered_maplEintcOl1tcLcLHGCalTowergR_TClassManip(theClass);
   return theClass;
   }

   static void unordered_maplEintcOl1tcLcLHGCalTowergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_unordered_maplEintcOl1tcLcLHGCalTowergR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<int,l1t::HGCalTower> : new unordered_map<int,l1t::HGCalTower>;
   }
   static void *newArray_unordered_maplEintcOl1tcLcLHGCalTowergR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<int,l1t::HGCalTower>[nElements] : new unordered_map<int,l1t::HGCalTower>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unordered_maplEintcOl1tcLcLHGCalTowergR(void *p) {
      delete ((unordered_map<int,l1t::HGCalTower>*)p);
   }
   static void deleteArray_unordered_maplEintcOl1tcLcLHGCalTowergR(void *p) {
      delete [] ((unordered_map<int,l1t::HGCalTower>*)p);
   }
   static void destruct_unordered_maplEintcOl1tcLcLHGCalTowergR(void *p) {
      typedef unordered_map<int,l1t::HGCalTower> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class unordered_map<int,l1t::HGCalTower>

namespace ROOT {
   static TClass *maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR_Dictionary();
   static void maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR_TClassManip(TClass*);
   static void *new_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR(void *p = 0);
   static void *newArray_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR(Long_t size, void *p);
   static void delete_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR(void *p);
   static void deleteArray_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR(void *p);
   static void destruct_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<l1t::HGCalMulticluster::EnergyInterpretation,double>*)
   {
      map<l1t::HGCalMulticluster::EnergyInterpretation,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<l1t::HGCalMulticluster::EnergyInterpretation,double>));
      static ::ROOT::TGenericClassInfo 
         instance("map<l1t::HGCalMulticluster::EnergyInterpretation,double>", -2, "map", 100,
                  typeid(map<l1t::HGCalMulticluster::EnergyInterpretation,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(map<l1t::HGCalMulticluster::EnergyInterpretation,double>) );
      instance.SetNew(&new_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR);
      instance.SetNewArray(&newArray_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR);
      instance.SetDelete(&delete_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR);
      instance.SetDeleteArray(&deleteArray_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR);
      instance.SetDestructor(&destruct_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<l1t::HGCalMulticluster::EnergyInterpretation,double> >()));

      ::ROOT::AddClassAlternate("map<l1t::HGCalMulticluster::EnergyInterpretation,double>","std::map<l1t::HGCalMulticluster::EnergyInterpretation, double, std::less<l1t::HGCalMulticluster::EnergyInterpretation>, std::allocator<std::pair<l1t::HGCalMulticluster::EnergyInterpretation const, double> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<l1t::HGCalMulticluster::EnergyInterpretation,double>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<l1t::HGCalMulticluster::EnergyInterpretation,double>*)0x0)->GetClass();
      maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<l1t::HGCalMulticluster::EnergyInterpretation,double> : new map<l1t::HGCalMulticluster::EnergyInterpretation,double>;
   }
   static void *newArray_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<l1t::HGCalMulticluster::EnergyInterpretation,double>[nElements] : new map<l1t::HGCalMulticluster::EnergyInterpretation,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR(void *p) {
      delete ((map<l1t::HGCalMulticluster::EnergyInterpretation,double>*)p);
   }
   static void deleteArray_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR(void *p) {
      delete [] ((map<l1t::HGCalMulticluster::EnergyInterpretation,double>*)p);
   }
   static void destruct_maplEl1tcLcLHGCalMulticlustercLcLEnergyInterpretationcOdoublegR(void *p) {
      typedef map<l1t::HGCalMulticluster::EnergyInterpretation,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<l1t::HGCalMulticluster::EnergyInterpretation,double>

namespace {
  void TriggerDictionaryInitialization_DataFormatsL1THGCal_xr_Impl() {
    static const char* headers[] = {
"0",
0
    };
    static const char* includePaths[] = {
"/uscms_data/d3/nswood/Notebooks/AE_Dev/models/CMSSW_12_5_2_patch1/src",
"/uscms_data/d3/nswood/Notebooks/AE_Dev/models/CMSSW_12_5_2_patch1/poison",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/cms/cmssw-patch/CMSSW_12_5_2_patch1/src",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/pcre/8.43-28d54724578a9006cf0dca75629374e3/include",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/bz2lib/1.0.6-86270889250d9cb8193d1963706a39cb/include",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/gsl/2.6-b614983d7a3915ce8c14658bc72be5cb/include",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/libuuid/2.34-fe91b21b8e54a48f2d45894d9da65f14/include",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/xz/5.2.5-d6fed2038c4e8d6e04531d1adba59f37/include",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/zlib/1.2.11-71514f01d2850dfd0bcd391557259a58/include",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/eigen/82dd3710dac619448f50331c1d6a35da673f764a-01f0fbbc69fe5c11dd0acfe3c748f30b/include/eigen3",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/fmt/8.0.1-b8a6534feba2e3dac314eff5040afd69/include",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/md5/1.0.0-0440f43b57c5656322f7cd7a65f85771/include",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/OpenBLAS/0.3.15-04b535a741a2f5a1f273ae128823f6ef/include",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/external/tinyxml2/6.2.0-b4ef6e4242045ed0c243ef457f5b32a5/include",
"/cvmfs/cms.cern.ch/slc7_amd64_gcc10/lcg/root/6.24.07-a31cbfc28a0c92b3c007615905b5b9b2/include/",
"/uscms_data/d3/nswood/Notebooks/AE_Dev/models/CMSSW_12_5_2_patch1/",
0
    };
    static const char* fwdDeclCode = R"DICTFWDDCLS(
#line 1 "DataFormatsL1THGCal_xr dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
namespace l1t{class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCFETriggerDigi.h")))  HGCFETriggerDigi;}
namespace std{template <typename _Tp> class __attribute__((annotate("$clingAutoload$bits/allocator.h")))  __attribute__((annotate("$clingAutoload$string")))  allocator;
}
namespace edm{template <typename T> class __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/Ptr.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCFETriggerDigiDefs.h")))  Ptr;
}
namespace l1t{class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalTriggerSums.h")))  HGCalTriggerSums;}
namespace edm{template <typename T> class __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/HolderToVectorTrait_Ptr_specialization.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalCluster.h")))  PtrVector;
}
namespace l1t{class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalConcentratorData.h")))  HGCalConcentratorData;}
namespace l1t{class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalCluster.h")))  HGCalCluster;}
namespace l1t{class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalTriggerCell.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalCluster.h")))  HGCalTriggerCell;}
namespace l1t{class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalMulticluster.h")))  HGCalMulticluster;}
namespace l1t{class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalTowerMap.h")))  HGCalTowerMap;}
namespace l1t{class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalTower.h")))  HGCalTower;}
namespace edm{template <typename T> struct __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/SortedCollection.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCFETriggerDigiDefs.h")))  StrictWeakOrdering;
}
namespace edm{template <typename T> class __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/Wrapper.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCFETriggerDigiDefs.h")))  Wrapper;
}
template <class T> class __attribute__((annotate("$clingAutoload$DataFormats/L1Trigger/interface/BXVector.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalCluster.h")))  BXVector;

namespace std{template <typename _Tp> struct __attribute__((annotate("$clingAutoload$bits/functional_hash.h")))  __attribute__((annotate("$clingAutoload$string")))  hash;
}
namespace std{template <typename _Tp = void> struct __attribute__((annotate("$clingAutoload$bits/stl_function.h")))  __attribute__((annotate("$clingAutoload$string")))  equal_to;
}
namespace std{template <typename _T1, typename _T2> struct __attribute__((annotate("$clingAutoload$bits/stl_iterator.h")))  __attribute__((annotate("$clingAutoload$string")))  pair;
}
namespace l1t{template <class C> class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalClusterT.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalCluster.h")))  HGCalClusterT;
}
namespace l1t{class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalTowerID.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalTower.h")))  HGCalTowerID;}
namespace l1t{class __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/ClusterShapes.h")))  ClusterShapes;}
namespace l1t{typedef edm::Ptr<HGCFETriggerDigi> HGCFETriggerDigiPtr __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCFETriggerDigiDefs.h"))) ;}
namespace l1t{typedef BXVector<l1t::HGCalTriggerCell> HGCalTriggerCellBxCollection __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalTriggerCell.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalCluster.h"))) ;}
namespace l1t{typedef BXVector<l1t::HGCalCluster> HGCalClusterBxCollection __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalCluster.h"))) ;}
namespace l1t{typedef BXVector<l1t::HGCalMulticluster> HGCalMulticlusterBxCollection __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalMulticluster.h"))) ;}
namespace l1t{typedef BXVector<l1t::HGCalTower> HGCalTowerBxCollection __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalTower.h"))) ;}
namespace l1t{typedef BXVector<l1t::HGCalTowerMap> HGCalTowerMapBxCollection __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalTowerMap.h"))) ;}
namespace l1t{typedef BXVector<l1t::HGCalTriggerSums> HGCalTriggerSumsBxCollection __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalTriggerSums.h"))) ;}
namespace l1t{typedef BXVector<l1t::HGCalConcentratorData> HGCalConcentratorDataBxCollection __attribute__((annotate("$clingAutoload$DataFormats/L1THGCal/interface/HGCalConcentratorData.h"))) ;}
)DICTFWDDCLS";
    static const char* payloadCode = R"DICTPAYLOAD(
#line 1 "DataFormatsL1THGCal_xr dictionary payload"

#ifndef CMS_DICT_IMPL
  #define CMS_DICT_IMPL 1
#endif
#ifndef _REENTRANT
  #define _REENTRANT 1
#endif
#ifndef GNUSOURCE
  #define GNUSOURCE 1
#endif
#ifndef __STRICT_ANSI__
  #define __STRICT_ANSI__ 1
#endif
#ifndef GNU_GCC
  #define GNU_GCC 1
#endif
#ifndef _GNU_SOURCE
  #define _GNU_SOURCE 1
#endif
#ifndef EIGEN_DONT_PARALLELIZE
  #define EIGEN_DONT_PARALLELIZE 1
#endif
#ifndef TBB_USE_GLIBCXX_VERSION
  #define TBB_USE_GLIBCXX_VERSION 100300
#endif
#ifndef TBB_SUPPRESS_DEPRECATED_MESSAGES
  #define TBB_SUPPRESS_DEPRECATED_MESSAGES 1
#endif
#ifndef TBB_PREVIEW_RESUMABLE_TASKS
  #define TBB_PREVIEW_RESUMABLE_TASKS 1
#endif
#ifndef TBB_PREVIEW_TASK_GROUP_EXTENSIONS
  #define TBB_PREVIEW_TASK_GROUP_EXTENSIONS 1
#endif
#ifndef BOOST_SPIRIT_THREADSAFE
  #define BOOST_SPIRIT_THREADSAFE 1
#endif
#ifndef PHOENIX_THREADSAFE
  #define PHOENIX_THREADSAFE 1
#endif
#ifndef BOOST_MATH_DISABLE_STD_FPCLASSIFY
  #define BOOST_MATH_DISABLE_STD_FPCLASSIFY 1
#endif
#ifndef BOOST_UUID_RANDOM_PROVIDER_FORCE_POSIX
  #define BOOST_UUID_RANDOM_PROVIDER_FORCE_POSIX 1
#endif
#ifndef CMSSW_GIT_HASH
  #define CMSSW_GIT_HASH "CMSSW_12_5_2_patch1"
#endif
#ifndef PROJECT_NAME
  #define PROJECT_NAME "CMSSW"
#endif
#ifndef PROJECT_VERSION
  #define PROJECT_VERSION "CMSSW_12_5_2_patch1"
#endif
#ifndef CMSSW_REFLEX_DICT
  #define CMSSW_REFLEX_DICT 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#include "DataFormats/L1THGCal/interface/HGCFETriggerDigi.h"
#include "DataFormats/L1THGCal/interface/HGCFETriggerDigiDefs.h"

#include "DataFormats/Common/interface/Ptr.h"
#include "DataFormats/Common/interface/PtrVector.h"
#include "DataFormats/L1THGCal/interface/HGCalCluster.h"
#include "DataFormats/L1THGCal/interface/HGCalMulticluster.h"
#include "DataFormats/L1THGCal/interface/HGCalTower.h"
#include "DataFormats/L1THGCal/interface/HGCalTowerMap.h"
#include "DataFormats/L1THGCal/interface/HGCalTriggerCell.h"
#include "DataFormats/L1THGCal/interface/HGCalTriggerSums.h"
#include "DataFormats/L1THGCal/interface/HGCalConcentratorData.h"

#include "DataFormats/L1THGCal/interface/ClusterShapes.h"

#undef  _BACKWARD_BACKWARD_WARNING_H
)DICTPAYLOAD";
    static const char* classesHeaders[] = {
"BXVector<l1t::HGCalCluster>", payloadCode, "@",
"BXVector<l1t::HGCalConcentratorData>", payloadCode, "@",
"BXVector<l1t::HGCalMulticluster>", payloadCode, "@",
"BXVector<l1t::HGCalTower>", payloadCode, "@",
"BXVector<l1t::HGCalTowerMap>", payloadCode, "@",
"BXVector<l1t::HGCalTriggerCell>", payloadCode, "@",
"BXVector<l1t::HGCalTriggerSums>", payloadCode, "@",
"edm::Ptr<l1t::HGCFETriggerDigi>", payloadCode, "@",
"edm::Ptr<l1t::HGCalCluster>", payloadCode, "@",
"edm::Ptr<l1t::HGCalConcentratorData>", payloadCode, "@",
"edm::Ptr<l1t::HGCalTowerMap>", payloadCode, "@",
"edm::Ptr<l1t::HGCalTriggerCell>", payloadCode, "@",
"edm::Ptr<l1t::HGCalTriggerSums>", payloadCode, "@",
"edm::PtrVector<l1t::HGCalTowerMap>", payloadCode, "@",
"edm::Ref<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >", payloadCode, "@",
"edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> >", payloadCode, "@",
"edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >", payloadCode, "@",
"edm::Wrapper<BXVector<l1t::HGCalCluster> >", payloadCode, "@",
"edm::Wrapper<BXVector<l1t::HGCalConcentratorData> >", payloadCode, "@",
"edm::Wrapper<BXVector<l1t::HGCalMulticluster> >", payloadCode, "@",
"edm::Wrapper<BXVector<l1t::HGCalTower> >", payloadCode, "@",
"edm::Wrapper<BXVector<l1t::HGCalTowerMap> >", payloadCode, "@",
"edm::Wrapper<BXVector<l1t::HGCalTriggerCell> >", payloadCode, "@",
"edm::Wrapper<BXVector<l1t::HGCalTriggerSums> >", payloadCode, "@",
"edm::Wrapper<edm::Ptr<l1t::HGCalCluster> >", payloadCode, "@",
"edm::Wrapper<edm::Ptr<l1t::HGCalConcentratorData> >", payloadCode, "@",
"edm::Wrapper<edm::Ptr<l1t::HGCalTowerMap> >", payloadCode, "@",
"edm::Wrapper<edm::Ptr<l1t::HGCalTriggerCell> >", payloadCode, "@",
"edm::Wrapper<edm::Ptr<l1t::HGCalTriggerSums> >", payloadCode, "@",
"edm::Wrapper<edm::PtrVector<l1t::HGCalCluster> >", payloadCode, "@",
"edm::Wrapper<edm::PtrVector<l1t::HGCalConcentratorData> >", payloadCode, "@",
"edm::Wrapper<edm::PtrVector<l1t::HGCalTowerMap> >", payloadCode, "@",
"edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerCell> >", payloadCode, "@",
"edm::Wrapper<edm::PtrVector<l1t::HGCalTriggerSums> >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi,edm::refhelper::FindUsingAdvance<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> >,l1t::HGCFETriggerDigi> > >", payloadCode, "@",
"edm::Wrapper<edm::SortedCollection<l1t::HGCFETriggerDigi,edm::StrictWeakOrdering<l1t::HGCFETriggerDigi> > >", payloadCode, "@",
"edm::Wrapper<l1t::HGCFETriggerDigiCollection>", payloadCode, "@",
"edm::Wrapper<l1t::HGCFETriggerDigiPtrVector>", payloadCode, "@",
"edm::Wrapper<l1t::HGCFETriggerDigiRefVector>", payloadCode, "@",
"edm::Wrapper<l1t::HGCalClusterBxCollection>", payloadCode, "@",
"edm::Wrapper<l1t::HGCalConcentratorDataBxCollection>", payloadCode, "@",
"edm::Wrapper<l1t::HGCalMulticlusterBxCollection>", payloadCode, "@",
"edm::Wrapper<l1t::HGCalTowerBxCollection>", payloadCode, "@",
"edm::Wrapper<l1t::HGCalTowerMapBxCollection>", payloadCode, "@",
"edm::Wrapper<l1t::HGCalTriggerCellBxCollection>", payloadCode, "@",
"edm::Wrapper<l1t::HGCalTriggerSumsBxCollection>", payloadCode, "@",
"edm::Wrapper<std::unordered_map<unsigned int,float,std::hash<unsigned int>,std::equal_to<unsigned int> > >", payloadCode, "@",
"edm::Wrapper<std::unordered_map<unsigned int,std::array<float,16>,std::hash<unsigned int>,std::equal_to<unsigned int> > >", payloadCode, "@",
"edm::Wrapper<std::unordered_map<unsigned int,std::array<float,48>,std::hash<unsigned int>,std::equal_to<unsigned int> > >", payloadCode, "@",
"edm::Wrapper<unordered_map<unsigned int,array<float,16> > >", payloadCode, "@",
"edm::Wrapper<unordered_map<unsigned int,array<float,48> > >", payloadCode, "@",
"edm::Wrapper<unordered_map<unsigned int,float> >", payloadCode, "@",
"edm::Wrapper<vector<edm::Ptr<l1t::HGCFETriggerDigi> > >", payloadCode, "@",
"l1t::ClusterShapes", payloadCode, "@",
"l1t::HGCFETriggerDigi", payloadCode, "@",
"l1t::HGCFETriggerDigiCollection", payloadCode, "@",
"l1t::HGCFETriggerDigiPtr", payloadCode, "@",
"l1t::HGCFETriggerDigiPtrVector", payloadCode, "@",
"l1t::HGCFETriggerDigiRef", payloadCode, "@",
"l1t::HGCFETriggerDigiRefVector", payloadCode, "@",
"l1t::HGCalCluster", payloadCode, "@",
"l1t::HGCalClusterBxCollection", payloadCode, "@",
"l1t::HGCalClusterT<l1t::HGCalCluster>", payloadCode, "@",
"l1t::HGCalClusterT<l1t::HGCalTriggerCell>", payloadCode, "@",
"l1t::HGCalClusterT<l1t::HGCalTriggerSums>", payloadCode, "@",
"l1t::HGCalConcentratorData", payloadCode, "@",
"l1t::HGCalConcentratorDataBxCollection", payloadCode, "@",
"l1t::HGCalMulticluster", payloadCode, "@",
"l1t::HGCalMulticlusterBxCollection", payloadCode, "@",
"l1t::HGCalTower", payloadCode, "@",
"l1t::HGCalTowerBxCollection", payloadCode, "@",
"l1t::HGCalTowerID", payloadCode, "@",
"l1t::HGCalTowerMap", payloadCode, "@",
"l1t::HGCalTowerMapBxCollection", payloadCode, "@",
"l1t::HGCalTriggerCell", payloadCode, "@",
"l1t::HGCalTriggerCellBxCollection", payloadCode, "@",
"l1t::HGCalTriggerSums", payloadCode, "@",
"l1t::HGCalTriggerSumsBxCollection", payloadCode, "@",
nullptr
};
    static bool isInitialized = false;
    if (!isInitialized) {
      TROOT::RegisterModule("DataFormatsL1THGCal_xr",
        headers, includePaths, payloadCode, fwdDeclCode,
        TriggerDictionaryInitialization_DataFormatsL1THGCal_xr_Impl, {}, classesHeaders, /*hasCxxModule*/false);
      isInitialized = true;
    }
  }
  static struct DictInit {
    DictInit() {
      TriggerDictionaryInitialization_DataFormatsL1THGCal_xr_Impl();
    }
  } __TheDictionaryInitializer;
}
void TriggerDictionaryInitialization_DataFormatsL1THGCal_xr() {
  TriggerDictionaryInitialization_DataFormatsL1THGCal_xr_Impl();
}
